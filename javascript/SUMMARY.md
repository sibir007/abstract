# javascript

## Строгий режим — "use strict"

`"use strict";`

### Консоль браузера

'use strict'; `Shift+Enter` для перехода на новую строку>

## Переменные

    let user = 'John', age = 25, message = 'Hello';

    var user // это устаревший способ объявления.

### Константы

    const COLOR_RED = "#F00";

## Типы данных

### number

`let n = 123;`
`n = 12.345;`
`alert( Infinity ); // Infinity`

`alert( "не число" / 2 ); // NaN, такое деление является ошибкой`
юбая математическая операция с NaN возвращает NaN

### BigInt

`// символ "n" в конце означает, что это BigInt`
`const bigInt = 1234567890123456789012345678901234567890n;`

### string

`let str = "Привет";`
`let str2 = 'Одинарные кавычки тоже подойдут';`
`let phrase = \`Обратные кавычки позволяют встраивать переменные ${str}\`;`

### boolean

`let nameFieldChecked = true; // да, поле отмечено`
`let ageFieldChecked = false; // нет, поле не отмечено`

### null

`let age = null;` специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно»

### undefined

`let age;`
`alert(age); // выведет "undefined"`
`name = undefined;` не рекомендуется
null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

### object

### symbol

используется для создания уникальных идентификаторов в объектах

### Оператор typeof

`// Обычный синтаксис`
`typeof 5 // Выведет "number"`
`// Синтаксис, напоминающий вызов функции (встречается реже)`
`typeof(5) // Также выведет "number"`

`typeof undefined // "undefined"`
`typeof 0 // "number"`
`typeof 10n // "bigint"`
`typeof true // "boolean"`
`typeof "foo" // "string"`
`typeof Symbol("id") // "symbol"`
`typeof Math // "object"  (1)`
`typeof null // "object"  (2)`
`typeof alert // "function"  (3)`

## Взаимодействие: alert, prompt, confirm

`alert("Hello");`
`result = prompt(title, [default]);`
`result = confirm(question); // true, folse`

## Преобразование типов

### Строковое преобразование

`let value = true;`
`alert(typeof value); // boolean`
`value = String(value); // теперь value это строка "true"`
`alert(typeof value); // string`

### Численное преобразование

`alert( "6" / "2" ); // 3, строки преобразуются в числа`

`let str = "123";`
`alert(typeof str); // string`
`let num = Number(str); // становится числом 123`
`alert(typeof num); // number`

`let age = Number("Любая строка вместо числа");`
`alert(age); // NaN, преобразование не удалось`

`undefined` NaN
`null` 0
`true / false` 1 / 0
`string` Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

### Логическое преобразование

`false` Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN.
`true` Все остальные значения становятся

### Базовые операторы, математика

Сложение +,
Вычитание -,
Умножение *,
Деление /,
Взятие остатка от деления %,
Возведение в степень **.

### Сложение строк при помощи бинарного +

`let s = "моя" + "строка";`
`alert(s); // моястрока`

`alert(2 + 2 + '1' ); // будет "41", а не "221"`

`alert( 6 - '2' ); // 4, '2' приводится к числу`
`alert( '6' / '2' ); // 3, оба операнда приводятся к числам`

### Приведение к числу, унарный +

`// Не влияет на числа`
`let x = 1;`
`alert( +x ); // 1`
`let y = -2;`
`alert( +y ); // -2`

`// Преобразует не числа в числа`
`alert( +true ); // 1`
`alert( +"" );   // 0`

`let apples = "2";`
`let oranges = "3";`
`alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки`

`// оба операнда предварительно преобразованы в числа`
`alert( +apples + +oranges ); // 5`

### Приоритет операторов

15 унарный плюс +
15 унарный минус -
14 возведение в степень **
13 умножение *
13 деление /
12 сложение +
12 вычитание -
2 присваивание =

### Сокращённая арифметика с присваиванием

`let n = 2;`
`n += 5; // теперь n = 7 (работает как n = n + 5)`
`n *= 2; // теперь n = 14 (работает как n = n * 2)`
`alert( n ); // 14`

### Инкремент/декремент

`let counter = 1;`
`let a = ++counter; // (*)`
`alert(a); // 2`

`let counter = 1;`
`let a = counter++; // (*) меняем ++counter на counter++`
`alert(a); // 1`
`alert(counter); // 2`

### Побитовые операторы

AND(и) ( & )
OR(или) ( | )
XOR(побитовое исключающее или) ( ^ )
NOT(не) ( ~ )
LEFT SHIFT(левый сдвиг) ( << )
RIGHT SHIFT(правый сдвиг) ( >> )
ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

### Оператор «запятая»

`let a = (1 + 2, 3 + 4);`
`alert( a ); // 7 (результат вычисления 3 + 4)`
первое выражение 1 + 2 выполняется, а результат отбрасывается. Затем идёт 3 + 4, выражение выполняется и возвращается результат.

`a = 1 + 2, 3 + 4;`
`alert(a); // 3`

## Операторы сравнения

`alert( 2 > 1 );  // true (верно)`
`alert( 2 == 1 ); // false (неверно)`
`alert( 2 != 1 ); // true (верно)`

`let result = 5 > 4; // результат сравнения присваивается переменной result`
`alert( result ); // true`

### Сравнение строк

Используется кодировка Unicode, а не настоящий алфавит
`alert( 'Я' > 'А' ); // true`
`alert( 'Коты' > 'Кода' ); // true`
`alert( 'Сонный' > 'Сон' ); // true`

### Сравнение разных типов

При сравнении значений разных типов JavaScript приводит каждое из них к числу.
`alert( '2' > 1 ); // true, строка '2' становится числом 2`
`alert( '01' == 1 ); // true, строка '01' становится числом 1`

`alert( true == 1 ); // true`
`alert( false == 0 ); // true`

`let a = 0;`
`alert( Boolean(a) ); // false`
`let b = "0";`
`alert( Boolean(b) ); // true`
`alert(a == b); // true!`

### Строгое сравнение

`alert( 0 == false ); // true`
`alert( '' == false ); // true`
`alert( 0 === false ); // false, так как сравниваются разные типы`

### Сравнение с null и undefined

`alert( null === undefined ); // false`
`alert( null == undefined ); // true`

При использовании математических операторов и других операторов сравнения < > <= >= значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

Странный результат сравнения null и 0
`alert( null > 0 );  // (1) false`
`alert( null == 0 ); // (2) false`
`alert( null >= 0 ); // (3) true`
для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.

### Несравненное значение undefined

Значение undefined несравнимо с другими значениями:
`alert( undefined > 0 ); // false (1)`
`alert( undefined < 0 ); // false (2)`
`alert( undefined == 0 ); // false (3)`
`alert( undefined == false); // false (4)`

### Как избежать проблем

Относитесь очень осторожно к любому сравнению с `undefined/null`, кроме случаев строгого равенства `===`.
Не используйте сравнения `>= > < <=` с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

## Условное ветвление: if, '?'

### Инструкция «if»

`if (year == 2015) alert( 'Вы правы!' );`

`let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');`
`if (year < 2015) {`
  `alert( 'Это слишком рано...' );`
`} else if (year > 2015) {`
  `alert( 'Это поздновато' );`
`} else {`
  `alert( 'Верно!' );`
`}`

### Условный оператор „?“

`let accessAllowed = (age > 18) ? true : false;`
`// то же самое`
`let accessAllowed = age > 18 ? true : false;`
`let accessAllowed = age > 18;`

`let message = (age < 3) ? 'Здравствуй, малыш!' :`
  `(age < 18) ? 'Привет!' :`
  `(age < 100) ? 'Здравствуйте!' :`
  `'Какой необычный возраст!';`

не рекомендуется
`let company = prompt('Какая компания создала JavaScript?', '');`
`(company == 'Netscape') ?`
   `alert('Верно!') : alert('Неправильно.');`

## Логические операторы

### || (ИЛИ)

ИЛИ "||" находит первое истинное значение, если все операнды являются ложными (false), возвращает последний из них
`alert( true || true );   // true`
`alert( false || true );  // true`
`alert( true || false );  // true`
`alert( false || false ); // false`

`alert( 1 || 0 ); // 1 (1 - истинное значение)`
`alert( true || 'какая-то строка' ); // true`
`alert( null || 1 ); // 1 (первое истинное значение)`
`alert( null || 0 || 1 ); // 1 (первое истинное значение)`
`alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)`

#### Получение первого истинного значения из списка переменных или выражений

`let firstName = "";`
`let lastName = "";`
`let nickName = "Суперкодер";`

`alert( firstName || lastName || nickName || "Аноним"); // Суперкодер`

#### Сокращённое вычисление

`true || alert("никогда не сработает");`
`false || alert("сработает");`

### ||= (Логическое присваивание ИЛИ)

`a ||= b;`
`a || (a = b);`

### && (И)

`alert( true && true );   // true`
`alert( false && true );  // false`
`alert( true && false );  // false`
`alert( false && false ); // false`

И «&&» находит первое ложное значение, если все операнды были истинными, возвращается последний
`result = value1 && value2 && value3;`

`alert( 1 && 2 && null && 3 ); // null`
`alert( 1 && 2 && 3 ); // 3`

Приоритет оператора && больше, чем у ||

### &&= (Логическое присваивание И)

`a &&= b;`
`a && (a = b);`

`let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=`
`greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")`
`alert( greeting ) // "Привет, пользователь!"`

### ! (НЕ)

`alert( !true ); // false`
`alert( !0 ); // true`

`alert( !!"непустая строка" ); // true`
`alert( !!null ); // false`

## Операторы нулевого слияния и присваивания: '??', '??='

### Оператор нулевого слияния (??)

`result = a ?? b`

Результат выражения a ?? b будет следующим:
если a определено, то a,
если a не определено, то b.

тоже самое
`result = (a !== null && a !== undefined) ? a : b;`

`let user;`
`alert(user ?? "Аноним"); // Аноним (user не существует)`

`let user = "Иван";`
`alert(user ?? "Аноним"); // Иван (user существует)`

`let firstName = null;`
`let lastName = null;`
`let nickName = "Суперкодер";`
`// показывает первое значение, которое определено:`
`alert(firstName ?? lastName ?? nickName ?? "Аноним");`

#### Использование ?? вместе с && или ||

`let x = 1 && 2 ?? 3; // Синтаксическая ошибка`
`let x = (1 && 2) ?? 3; // Работает без ошибок`
`alert(x); // 2`

#### Оператор нулевого присваивания (??=)

`x ??= y`

`let userAge = null;`
`userAge ??= 18;`
`alert(userAge) // 18`

## Циклы while и for

let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}

let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}

