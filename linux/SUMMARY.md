# Linux

## Операторы объединения команд в Linux & | ; && ! || &&-|| \ ()

### Оператор амперсанда (&)

& — команда выполняется в фоновом режиме. Нужно ввести команду с пробелом и ‘&‘. Можно выполнить более одной команды в фоновом режиме за один раз.

`ping c5 disweb.ru &`

Запуск двух команд в фоновом режиме одновременно:

`sudo apt update & sudo apt upgrade &`

### Оператор точка с запятой (;)

Оператор точка с запятой позволяет запускать несколько команд за один раз, и выполнение команды происходит последовательно.

`sudo apt update ; sudo apt upgrade ; mkdir test`

### Оператор AND (&&)

Оператор AND (&&) будет выполнять вторую команду только в том случае, если при выполнении первой команды SUCCEEDS, т.е. состояние выхода первой команды равно «0» — программа выполнена успешно. Эта команда очень полезна при проверке состояния выполнения последней команды.

Например, я хочу посетить сайт sedicomm.com с помощью команды links в терминале, но перед этим мне нужно проверить, является ли хост доступным или нет.

`ping -c3 www.sedicomm.com && links www.sedicomm.com`

### Оператор OR (||)

Оператор OR (||) очень похож на оператор «else» в программировании. Вышеуказанный оператор позволяет вам выполнять вторую команду только в случае сбоя при выполнении первой команды, то есть состояние выхода первой команды равно «1» — программа выполнена НЕ успешно».

Например, я хочу выполнить «apt-get update» из учетной записи без полномочий root, и если первая команда не будет выполнена, тогда будет выполнена вторая команда «links <www.sedicomm.com»>.

`sudo apt update || links sedicomm.com`

Что, если первая команда выполнена успешно, со статусом выхода «0«? Очевидно! Вторая команда не будет выполнена.

`mkdir test || links sedicomm.com`

### Оператор NOT (!)

Оператор NOT (!) очень похож на оператор «кроме«. Эта команда выполнит все, кроме предоставленного условия. Чтобы понять как это работает, создайте каталог «sedicomm» в вашем домашнем каталоге и перейдите к нему с помощью команды «cd«.

`mkdir sedicomm`
`cd sedicomm`

Затем создайте несколько типов файлов в папке «sedicomm».

`touch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html`

Смотрите, мы создали все новые файлы в папке «sedicomm».

`ls a.doc a.html a.pdf a.xml a.doc b.html b.pdf b.xml`

Теперь удалите все файлы, за исключением файла «html»одновременно, умным способом.

`rm -r !(*.html)`

Просто чтобы проверить, последнее исполнение. Перечислите все доступные файлы с помощью команды ls.

`ls a.html b.html`

### Оператор AND-OR (&& — ||)

Вышеуказанный оператор фактически является комбинацией оператора «AND» и «OR». Это очень похоже на утверждение «если-еще».

Например, давайте сделаем ping на disweb.ru, если успешно то выведем на экран ‘Verified‘, если ping не успешный, то выведен на экран ‘Host Down‘.

`ping -c3 disweb.ru && echo "Verified" || echo "Host Down"`

Пример вывода

PING disweb.ru (62.109.11.132) 56(84) bytes of data.
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=1 ttl=61 time=0.906 ms
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=2 ttl=61 time=0.800 ms
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=3 ttl=61 time=0.791 ms

--- disweb.ru ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 0.791/0.832/0.906/0.057 ms
Verified

### Оператор потока PIPE (|)

Этот оператор потока PIPE очень полезен, когда выходные данные первой команды действуют как входные данные для второй команды. Например, направьте вывод команды «ls -l» на «less» и посмотрите вывод всего скрипта.

`ls -l | less`

### Оператор комбинации команд {}

Объедините две или более команд, вторая команда зависит от выполнения первой команды.

Например, проверьте, доступен ли каталог «bin», и выведите соответствующий вывод.

`[ -d"bin" ] || { echo Directory does not exist, creating directory now.; mkdir bin; } && echo Directory exists.`

### Оператор приоритета ()

Оператор позволяет выполнить команду в порядке приоритета.

`Command_x1 && Command_x2 || Command_x3 && Command_x4`

В приведенной выше псевдокоманде, что если Command_x1 завершится неудачно? Ни один из Command_x2, Command_x3, Command_x4 не будет выполнен, для этого мы используем оператор приоритета вот так:

`(Command_x1 && Command_x2) || (Command_x3 && Command_x4)`

В вышеприведенном скрипте, если Command_x1 завершается ошибкой, Command_x2 также завершается ошибкой, но все же выполнение Command_x3 и Command_x4 зависит от состояния выхода Command_x3.

### Оператор конкатенации (\)

Оператор конкатенации (\), как указывает имя, используется для объединения больших команд в нескольких строках оболочки. Например, команда ниже откроет текстовый файл test(1).txt.

`nano test\(1\).txt`

## Перенаправление ввода/вывода в Linux

### Потоки

Стандартный ввод при работе пользователя в терминале передается через клавиатуру.

Стандартный вывод и стандартная ошибка отображаются на дисплее терминала пользователя в виде текста.

Ввод и вывод распределяется между тремя стандартными потоками:

- stdin — стандартный ввод (клавиатура),
- stdout — стандартный вывод (экран),
- stderr — стандартная ошибка (вывод ошибок на экран).

Потоки также пронумерованы:

- stdin — 0,
- stdout — 1,
- stderr — 2.

Из стандартного ввода команда может только считывать данные, а два других потока могут использоваться только для записи. Данные выводятся на экран и считываются с клавиатуры, так как стандартные потоки по умолчанию ассоциированы с терминалом пользователя. Потоки можно подключать к чему угодно: к файлам, программам и даже устройствам. В командном интерпретаторе bash такая операция называется перенаправлением:

- `< file` — использовать файл как источник данных для стандартного потока ввода.
- `> file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- `2> file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- `>>file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- `2>>file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- `&>file` или `>&file` — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: `>file 2>&1`.

### Стандартный ввод

Стандартный входной поток обычно переносит данные от пользователя к программе. Программы, которые предполагают стандартный ввод, обычно получают входные данные от устройства типа клавиатура. Стандартный ввод прекращается по достижении EOF (конец файла), который указывает на то, что данных для чтения больше нет.

EOF вводится нажатием сочетания клавиш `Ctrl+D`.

Рассмотрим работу со стандартным выводом на примере команды `cat` (от CONCATENATE, в переводе «связать» или «объединить что-то»).

**Cat** обычно используется для объединения содержимого двух файлов.

**Cat** отправляет полученные входные данные на дисплей терминала в качестве стандартного вывода и останавливается после того как получает EOF.

В открывшейся строке введите, например, 1 и нажмите клавишу Enter. На дисплей выводится 1. Введите a и нажмите клавишу Enter. На дисплей выводится a.

Дисплей терминала выглядит следующим образом:

    test@111:~/stream$ cat
    1
    1
    a
    a

Для завершения ввода данных следует нажать сочетание клавиш Ctrl + D.

### Стандартный вывод

Стандартный вывод записывает данные, сгенерированные программой. Когда стандартный выходной поток не перенаправляется в какой-либо файл, он выводит текст на дисплей терминала.

При использовании без каких-либо дополнительных опций, команда echo выводит на экран любой аргумент, который передается ему в командной строке:

    echo Пример

Аргументом является то, что получено программой, в результате на дисплей терминала будет выведено:

    Пример

Команда объединяет три файла: file1, file2 и file3 в один файл bigfile:

    cat file1 file1 file1 > bigfile

### Стандартная ошибка

Стандартная ошибка записывает ошибки, возникающие в ходе исполнения программы. Как и в случае стандартного вывода, по умолчанию этот поток выводится на терминал дисплея.

При запуске без аргументов ls выводит содержимое в пределах текущего каталога.

Введем команду ls с каталогом % в качестве аргумента:

    ls %

В результате должно выводиться содержимое соответствующей папки. Но так как каталога % не существует, на дисплей терминала будет выведен следующий текст стандартной ошибки:

    ls: cannot access %: No such file or directory

### Перенаправление потока

Linux включает в себя команды перенаправления для каждого потока.

Команды со знаками > или < означают перезапись существующего содержимого файла:

- `>` — стандартный вывод,
- `<` — стандартный ввод,
- `2>` — стандартная ошибка.

Команды со знаками >> или << не перезаписывают существующее содержимое файла, а присоединяют данные к нему:

- `>>` — стандартный вывод,
- `<<` — стандартный ввод,
- `2>>` — стандартная ошибка.

В приведенном примере команда cat используется для записи в файл file1, который создается в результате цикла:

    cat > file1
    a
    b
    c

Для завершения цикла нажмите сочетание клавиш Ctrl + D.

Если файла file1 не существует, то в текущем каталоге создается новый файл с таким именем.

Для просмотра содержимого файла file1 введите команду:

    cat file1

В результате на дисплей терминала должно быть выведено следующее:

    a
    b
    c

Для перезаписи содержимого файла введите следующее:

    cat > file1
    1
    2
    3

Для завершения цикла нажмите сочетание клавиш `Ctrl + D`.

В результате на дисплей терминала должно быть выведено следующее:

      1
      2
      3

Предыдущего текста в текущем файле больше не существует, так как содержимое файла было переписано командой `>`.

Для добавления нового текста к уже существующему в файле с помощью двойных скобок `>>` выполните команду:

    cat >> file1
    a
    b
    c

Для завершения цикла нажмите сочетание клавиш Ctrl + D.

Откройте `file1` снова и в результате на дисплее монитора должно быть отражено следующее:

    1
    2
    3
    a
    b
    c

### Каналы

Каналы используются для перенаправления потока из одной программы в другую. Стандартный вывод данных после выполнения одной команды перенаправляется в другую через канал. Данные первой программы, которые получает вторая программа, не будут отображаться. На дисплей терминала будут выведены только отфильтрованные данные, возвращаемые второй командой.

Введите команду:

    ls | less

В результате каждый файл текущего каталога будет размещен на новой строке:

    file1
    file2
    t1
    t2

Перенаправлять данные с помощью каналов можно как из одной команды в другую, так и из одного файла к другому, а перенаправление с помощью > и >> возможно только для перенаправления данных в файлах.

Для сохранения имен файлов, содержащих строку «LOG», используется следующая команда:

    dir /catalog | find "LOG" > loglist

Вывод команды dir отсылается в команду-фильтр find. Имена файлов, содержащие строку «LOG», хранятся в файле loglist в виде списка (например, Config.log, Logdat.svd и Mylog.bat).

При использовании нескольких фильтров в одной команде рекомендуется разделять их с помощью знака канала |.

Фильтры

Фильтры представляют собой стандартные команды Linux, которые могут быть использованы без каналов:

- `find` — возвращает файлы с именами, которые соответствуют передаваемому аргументу.
- `grep` — возвращает только строки, содержащие (или не содержащие) заданное регулярное выражение.
- `tee` — перенаправляет стандартный ввод как стандартный вывод и один или несколько файлов.
- `tr` — находит и заменяет одну строку другой.
- `wc` — подсчитывает символы, линии и слова.

Как правило, все нижеприведенные команды работают как фильтры, если у них нет аргументов (опции могут быть):

- `cat` — считывает данные со стандартного потока ввода и передает их на стандартный поток вывода. Без опций работает как простой повторитель. С опциями может фильтровать пустые строки, нумеровать строки и делать другую подобную работу.
- `head` — показывает первые 10 строк (или другое заданное количество), считанных со стандартного потока ввода.
- `tail` — показывает последние 10 строк (или другое заданное количество), считанные со стандартного потока ввода. Важный частный случай tail -f, который в режиме слежения показывает концовку файла. Это используется, в частности, для просмотра файлов журнальных сообщений.
- `cut` — вырезает столбец (по символам или полям) из потока ввода и передает на поток вывода. В качестве разделителей полей могут использоваться любые символы.
- sort — сортирует данные в соответствии с какими-либо критериями, например, арифметически по второму столбцу.
- `uniq` — удаляет повторяющиеся строки. Или (с ключом -с) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.
- `bc` — вычисляет каждую отдельную строку потока и записывает вместо нее результат вычисления.
- `hexdump` — показывает шестнадцатеричное представление данных, поступающих на стандартный поток ввода.
- `strings` — выделяет и показывает в стандартном потоке (или файле) то, что напоминает строки. Всё что не похоже на строковые последовательности, игнорируется. Команда полезна в сочетании с grep для поиска интересующих строковых последовательностей в бинарных файлах.
- `sed` — обрабатывает текст в соответствии с заданным скриптом. Наиболее часто используется для замены текста в потоке: sed s/было/стало/g.
- `awk` — обрабатывает текст в соответствии с заданным скриптом. Как правило, используется для обработки текстовых таблиц, например, вывод ps aux и т.д.
- `sh -s` — текст, который передается на стандартный поток ввода sh -s. может интерпретироваться как последовательность команд shell. На выход передается результат их исполнения.
- `ssh` — средство удаленного доступа ssh, может работать как фильтр, который подхватывает данные, переданные ему на стандартный поток ввода, затем передает их на удаленный хост и подает на вход процессу программы, имя которой было передано ему в качестве аргумента. Результат выполнения программы (то есть то, что она выдала на стандартный поток вывода) передается со стандартного вывода ssh.

Если в качестве аргумента передается файл, команда-фильтр считывает данные из этого файла, а не со стандартного потока ввода (есть исключения, например, команда tr, обрабатывающая данные, поступающие исключительно через стандартный поток ввода).

Команда tee, как правило, используется для просмотра выводимого содержимого при одновременном сохранении его в файл.

    wc ~/stream | tee file2

Допускается перенаправление нескольких потоков в один файл:

    ls -z >> file3 2>&1

В результате сообщение о неверной опции «z» в команде ls будет записано в файл t2, поскольку stderr перенаправлен в файл.

Для просмотра содержимого файла file3 введите команду cat:

    cat file3

В результате на дисплее терминала отобразиться следующее:

    ls: invalid option -- 'z'
    Try 'ls --help' for more information.

## Как запустить процесс в фоне Linux

Для выполнения команды в фоновом режиме достаточно добавить в конце символ амперсанда (&):

    command &

В фоновом режиме можно одновременно запускать сразу два, три, четыре процесса и даже больше.

Работая в фоновом режиме, команда все равно продолжает выводить сообщения в терминал, из которого была запущена. Для этого она использует потоки stdout и stderr,  которые можно закрыть при помощи следующего синтаксиса:

    command > /dev/null 2>&1 &

Здесь `>/dev/null 2>&1` обозначает, что stdout будет перенаправлен на `/dev/null`, а stderr — к stdout.

Узнать состояние всех остановленных и выполняемых в фоновом режиме задач в рамках текущей сессии терминала можно при помощи утилиты jobs c использованием опции -l:

    jobs -l

В любое время можно вернуть процесс из фонового режима на передний план. Для этого служит команда fg:

    fg

Если в фоновом режиме выполняется несколько программ, следует также указывать номер. Например:

    fg %1

Для завершения фонового процесса применяют команду kill с номером программы:

    kill %1

### Как перевести процесс в фоновый режим

Если изначально процесс был запущен обычным способом, его можно перевести в фоновый режим, выполнив следующие действия:

- Остановить выполнение команды, нажав комбинацию клавиш `Ctrl+Z`.
- Перевести процесс в фоновый режим при помощи команды `bg`.

    bg

### Работа процессов в фоне

Закрытие терминала путем нажатия на крестик в верхнем углу экрана влечет за собой завершение всех фоновых процессов. Впрочем, есть несколько способов сохранить их  после того как связь с интерактивной оболочкой прервется. Первый способ — это удаление задачи из очереди заданий при помощи команды disown:

    disown

Как и в предыдущих случаях, при наличии нескольких одновременно выполняемых процессов следует  указывать номер того, относительно которого будет выполнено действие:

    disown %1

Убедиться, что задачи больше нет в списке заданий, можно, использовав уже знакомую утилиту jobs -l. А чтобы просмотреть перечень всех запущенных процессов (в том числе и отключенных) применяется команда

    ps aux

Второй способ сохранить запущенные процессы после прекращения работы терминала — команда nohup. Она выполняет другую команду, которая была указана в качестве аргумента, при этом игнорирует все сигналы SIGHUP (те, которые получает процесс при закрытии терминала). Для запуска команды в фоновом режиме нужно написать команду в виде:

    nohup command &

### Как убить процесс Linux

Управление процессами в операционной системе Linux осуществляется с помощью сигналов. В том числе и завершение любого процесса. Сигналы передает система, но также их может передавать пользователь с помощью специальных команд или даже сочетаний клавиш в терминале. Когда процессу приходит сигнал о необходимости завершиться, он должен выполнить некоторые подготовительные действия.

Необходимо завершить дочерние процессы, удалить временные файлы, сокеты и так далее. Но в зависимости от сложности ситуации процесс может реагировать не на все сигналы. Рассмотрим основные сигналы, которые используются для завершения процесса:

**SIGINT** - самый безобидный сигнал завершения, означает Interrupt. Он отправляется процессу, запущенному из терминала с помощью сочетания клавиш `Ctrl+C`. Процесс правильно завершает все свои действия и возвращает управление;
**SIGQUIT** - это еще один сигнал, который отправляется с помощью сочетания клавиш, программе, запущенной в терминале. Он сообщает ей что нужно завершиться и программа может выполнить корректное завершение или проигнорировать сигнал. В отличие от предыдущего, она генерирует дамп памяти. Сочетание клавиш `Ctrl+/`;
**SIGHUP** - сообщает процессу, что соединение с управляющим терминалом разорвано, отправляется, в основном, системой при разрыве соединения с интернетом;
**SIGTERM** - немедленно завершает процесс, но обрабатывается программой, поэтому позволяет ей завершить дочерние процессы и освободить все ресурсы;
**SIGKILL** - тоже немедленно завершает процесс, но, в отличие от предыдущего варианта, он не передается самому процессу, а обрабатывается ядром. Поэтому ресурсы и дочерние процессы остаются запущенными.

Важно понимать, что нужно дать процессу возможность завершиться корректно. Желательно, чтобы порты и сокеты были освобождены, закрыты и удаленны временные файлы. Поэтому никогда не передавайте сразу SIGKILL. Передавайте сигналы завершения в последовательности, как они перечислены выше.

Сначала `Ctrl+C`, если это возможно, затем SIGTERM - он хоть и завершает процесс, но делает эту культурно, и только в крайнем случае SIGKILL. А теперь рассмотрим как убить процесс по pid Linux на практике.

    kill -сигнал pid_процесса

Сигнал представляет собой один из выше перечисленных сигналов для завершения процесса. По умолчанию, если этот параметр не указан, используется сигнал SIGTERM, что является очень правильно. Также нам нужно указать какой процесс нужно завершить. Для этого используется уникальный идентификатор процесса - PID.

Допустим, у нас выполняется утилита ping. Мы хотим ее завершить с помощью kill. Тогда, сначала мы узнаем ее идентификатор с помощью команды ps:

    ps aux | grep ping

В первой строчке отобразится сама утилита ping, а во второй сама программа ps. Берем нужный PID и завершаем процесс с помощью SIGTERM:

    kill 20446

Или:

    kill -TERM 20446

И только если после этой команды процесс продолжил висеть, а это вы можете проверить, выполнив ps. Только теперь можно выполнить SIGKILL:

    kill -KILL 20446

#### Как завершить процесс с помощью pkill

Утилита pkill - это оболочка для kill, она ведет себя точно так же, и имеет тот же синтаксис, только в качестве идентификатора процесса ей нужно передать его имя. Утилита сканирует директорию proc и находит PID первого процесса с таким именем, затем отправляет ему SIGTERM. Таким образом, вы можете убить процесс по имени Linux. Например, если мы хотим завершить тот же ping:

    pkill ping

Также можно вручную задать тип сигнала:

    pkill -TERM ping

Вместо ps, вы можете использовать утилиту pgrep для поиска pid процесса, убедимся что наша программа завершена:

    pgrep ping

## Запись man программы в txt файл

`man <programm_name> | col -b > man_<programm_name>.txt`

## Bash-скрипты

### Начало

Итак, если говорить о командной строке, она позволяет выполнить несколько команд за один раз, введя их через точку с запятой:

`pwd ; whoami`

Используя подобный подход, вы можете совмещать сколько угодно команд в одной строке, ограничение — лишь в максимальном количестве аргументов, которое можно передать программе. Определить это ограничение можно с помощью такой команды:

`getconf ARG_MAX`

#### Как устроены bash-скрипты

Создайте пустой файл с использованием команды touch. В его первой строке нужно указать, какую именно оболочку мы собираемся использовать. Нас интересует bash, поэтому первая строка файла будет такой:

`#!/bin/bash`

Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:

```bash
#!/bin/bash
# This is a comment
pwd
whoami
```

Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.

#### Установка разрешений для файла сценария

Сделаем файл исполняемым:

`chmod +x ./myscript`

Теперь попытаемся его выполнить:

`./myscript`

#### Вывод сообщений

Для вывода текста в консоль Linux применяется команда echo. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:

```bash
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

#### Использование переменных

Существуют два типа переменных, которые можно использовать в bash-скриптах:

- Переменные среды
- Пользовательские переменные

##### Переменные среды

Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:

```bash
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"

#  если не нужно ссылаться на переменную
echo "I have \$1 in my pocket"
```

##### Пользовательские переменные

Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:

```bash
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

#### Подстановка команд

Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

- С помощью значка обратного апострофа `«`»`
- С помощью конструкции `$()`

Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:

```bash
mydir=`pwd`
```


При втором подходе то же самое записывают так:

```bash
mydir=$(pwd)
```

А скрипт, в итоге, может выглядеть так:

```bash
#!/bin/bash
mydir=$(pwd)
echo $mydir
```

#### Математические операции

```bash
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

#### Управляющая конструкция if-then

выглядит так:

if команда
then
команды
fi

А вот рабочий пример:

```bash
#!/bin/bash
if pwd
then
echo "It works"
fi
```

Скажем, надо найти некоего пользователя в /etc/passwd, и если найти его удалось, сообщить о том, что он существует.

```bash
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
```

#### Управляющая конструкция if-then-else

if команда
then
команды
else
команды
fi

Напишем такой скрипт:

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
```

вложенные условия. Выглядит это так:

if команда1
then
команды
elif команда2
then
команды
fi

если вторая команда вернёт ноль, выполнится второй блок кода.

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

#### Сравнение чисел

`n1 -eq n2` Возвращает истинное значение, если n1 равно n2.
`n1 -ge n2` Возвращает истинное значение, если n1больше или равно n2.
`n1 -gt n2` Возвращает истинное значение, если n1 больше n2.
`n1 -le n2` Возвращает истинное значение, если n1меньше или равно n2.
`n1 -lt n2` Возвращает истинное значение, если n1 меньше n2.
`n1 -ne n2` Возвращает истинное значение, если n1не равно n2.

```bash
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
```

#### Сравнение строк

`str1 = str2` Проверяет строки на равенство, возвращает истину, если строки идентичны.
`str1 != str2` Возвращает истину, если строки не идентичны.
`str1 < str2` Возвращает истину, если `str1` меньше, чем str2.
`str1 > str2` Возвращает истину, если `str1` больше, чем str2.
`-n str1` Возвращает истину, если длина `str1` больше нуля.
`-z str1` Возвращает истину, если длина `str1` равна нулю.

```bash
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

Вот как работа с этими операторами выглядит в коде:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:

`./myscript: line 5: [: too many arguments`

Для того, чтобы избавиться от этого предупреждения, заключим $val2 в двойные кавычки:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах.

```bash
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

строчная буква больше прописной.

#### Проверки файлов

`-d file` Проверяет, существует ли файл, и является ли он директорией.
`-e file` Проверяет, существует ли файл.
`-f file` Проверяет, существует ли файл, и является ли он файлом.
`-r file` Проверяет, существует ли файл, и доступен ли он для чтения.
`-s file` Проверяет, существует ли файл, и не является ли он пустым.
`-w file` Проверяет, существует ли файл, и доступен ли он для записи.
`-x file` Проверяет, существует ли файл, и является ли он исполняемым.
`file1 -nt file2` Проверяет, новее ли file1, чем file2.
`file1 -ot file2` Проверяет, старше ли file1, чем file2.
`-O file` Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
`-G file` Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

Опробуем одну из команд на практике:

```bash
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi
```

### часть 2: циклы

#### Циклы for

структура таких циклов:

for var in list
do
команды
done

##### Перебор простых значений

```bash
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
```

##### Перебор сложных значений

```bash
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
```

##### Инициализация цикла списком, полученным из результатов работы команды

```bash
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
```

Тут надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.

##### Разделители полей

Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:

- Пробел
- Знак табуляции
- Знак перевода строки

Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.

Для того, чтобы решить проблему, можно временно изменить переменную среды IFS. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:

`IFS=$'\n'`

После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.

```bash
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
do
  echo " $var"
done
```
Разделителями могут быть и другие символы. Например, выше мы выводили на экран содержимое файла /etc/passwd. Данные о пользователях в строках разделены с помощью двоеточий. Если в цикле нужно обрабатывать подобные строки, IFS можно настроить так:

`IFS=:`

##### Обход файлов, содержащихся в директории

вывести список файлов и папок:

```bash
#!/bin/bash
for file in /home/likegeeks/*
do
  if [ -d "$file" ]
  then
    echo "$file is a directory"
  elif [ -f "$file" ]
  then
    echo "$file is a file"
fi
done
```

##### Циклы for в стиле C

Схема цикла при подобном подходе выглядит так:

for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))


На bash это можно написать так:

`for (( a = 1; a < 10; a++ ))`

А вот рабочий пример:

```bash
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
  echo "number is $i"
done
```

#### Цикл while

while команда проверки условия

do

другие команды

done

Взглянем на пример скрипта с таким циклом:

```bash
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
  echo $var1
  var1=$[ $var1 - 1 ]
done
```

#### Вложенные циклы

```bash
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
  echo "Start $a:"
  for (( b = 1; b <= 3; b++ ))
  do
    echo " Inner loop: $b"
  done
done
```

#### Обработка содержимого файла

Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла /etc/passwd:

```bash
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
  echo "Values in $entry –"
  IFS=:
  for value in $entry
  do
    echo " $value"
  done
done
```

#### Управление циклами

##### Команда break

```bash
#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
do
  if [ $var1 -eq 5 ]
  then
    break
  fi
  echo "Iteration: $var1"
  var1=$(( $var1 + 1 ))
done
```

##### Команда continue

```bash
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
  if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
    then
      continue
  fi
  echo "Iteration number: $var1"
done
```

#### Обработка вывода, выполняемого в цикле

Оболочка создаст файл `myfile.txt` и перенаправит в этот файл вывод конструкции `for`

```bash
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
  echo "Number is $a"
done > myfile.txt
echo "finished."
```

#### Пример: поиск исполняемых файлов

```bash
#!/bin/bash
IFS=:
for folder in $PATH
do
  echo "$folder:"
  for file in $folder/*
  do
    if [ -x $file ]
      then
        echo " $file"
    fi
  done
done
```

### часть 3: параметры и ключи командной строки

Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Вызвав сценарий с параметрами, мы передаём ему некую информацию, с которой он может работать. Выглядит это так:

```bash
$ ./myscript 10 20
```
#### Чтение параметров командной строки

Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:

- $0 — имя скрипта.
- $1 — первый параметр.
- $2 — второй параметр — и так далее, вплоть до переменной $9, в которую попадает девятый параметр.

```bash
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
```

Запустим сценарий с параметрами:

`./myscript 5 10 15`

```bash
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```

Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:

`${10}`

#### Проверка параметров

Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:

```bash
#!/bin/bash
if [ -n "$1" ]
  then
    echo Hello $1.
else
  echo "No parameters found. "
fi
```

#### Подсчёт параметров

В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная $# содержит количество параметров, переданных сценарию при вызове.

Опробуем её:

```bash
#!/bin/bash
echo There were $# parameters passed.
```

#### Получение последнего параметра

```bash
#!/bin/bash
echo The last parameter was ${!#}
```

#### Захват всех параметров командной строки

Переменная `$*` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной `$@` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

Рассмотрим разницу между этими переменными на примерах. Сначала взглянем на их содержимое:

```bash
#!/bin/bash
echo "Using the \$* method: $*"
echo "-----------"
echo "Using the \$@ method: $@"
```

Теперь попробуем пройтись по содержимому этих переменных в циклах для того, чтобы увидеть разницу между ними:

```bash
#!/bin/bash
count=1
for param in "$*"
do
  echo "\$* Parameter #$count = $param"
  count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
  echo "\$@ Parameter #$count = $param"
  count=$(( $count + 1 ))
done
```

Переменная $* содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной $@ они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.

#### Команда shift

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1, а то, что было до этого в $1, теряется. Обратите внимание на то, что при этом значение переменной $0, содержащей имя скрипта, не меняется.

```bash
#!/bin/bash
count=1
while [ -n "$1" ]
do
  echo "Parameter #$count = $1"
  count=$(( $count + 1 ))
  shift
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 1 2 3 4 5 6
Parameter #1 = 1
Parameter #2 = 2
Parameter #3 = 3
Parameter #4 = 4
Parameter #5 = 5
Parameter #6 = 6
```

Используя команду shift, помните о том, что при каждом её вызове значение переменной $1 безвозвратно теряется.

#### Ключи командной строки

Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:

```bash
#!/bin/bash
echo
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option" ;;
    -c) echo "Found the -c option" ;;
    *) echo "$1 is not an option" ;;
  esac
  shift
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr –a –b –c –d
–a is not an option
–b is not an option
–c is not an option
–d is not an option
```

#### Как различать ключи и параметры

Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Эта последовательность — двойное тире (--). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:

```bash
#!/bin/bash
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option";;
    -c) echo "Found the -c option" ;;
    --) shift
      break ;;
    *) echo "$1 is not an option";;
  esac
  shift
done
  count=1
for param in $@
do
  echo "Parameter #$count: $param"
  count=$(( $count + 1 ))
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr -a -b -c -d -- 4 5 15
Found the -a option
Found the -b option
Found the -c option
-d is not an option
Parameter #1: 4
Parameter #2: 5
Parameter #3: 15
```

#### Обработка ключей со значениями

`./myscript -a test1 -b -c test2`

```bash
#!/bin/bash
while [ -n "$1" ]
  do
    case "$1" in
      -a) echo "Found the -a option";;
      -b) param="$2"
        echo "Found the -b option, with parameter value $param"
        shift ;;
      -c) echo "Found the -c option";;
      --) shift
        break ;;
      *) echo "$1 is not an option";;
    esac
    shift
  done
count=1
for param in "$@"
  do
    echo "Parameter #$count: $param"
    count=$(( $count + 1 ))
  done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr -a -b test1 -d
Found the -a option
Found the -b option, with parameter value test1
-d is not an option
```

#### Использование стандартных ключей

в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:

`-a` Вывести все объекты.
`-c` Произвести подсчёт.
`-d` Указать директорию.
`-e` Развернуть объект.
`-f` Указать файл, из которого нужно прочитать данные.
`-h` Вывести справку по команде.
`-i` Игнорировать регистр символов.
`-l` Выполнить полноформатный вывод данных.
`-n` Использовать неинтерактивный (пакетный) режим.
`-o` Позволяет указать файл, в который нужно перенаправить вывод.
`-q` Выполнить скрипт в quiet-режиме.
`-r` Обрабатывать папки и файлы рекурсивно.
`-s` Выполнить скрипт в silent-режиме.
`-v` Выполнить многословный вывод.
`-x` Исключить объект.
`-y` Ответить «yes» на все вопросы.

#### Получение данных от пользователя

Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда `read`

После получения данных, эта команда помещает их в переменную:

```bash
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
```

echo, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки

При вызове read можно указывать и несколько переменных:

```bash
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
```

Если, вызвав read, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`

```bash
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
```

Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду read можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:

```bash
#!/bin/bash
if read -t 5 -p "Enter your name: " name
  then
    echo "Hello $name, welcome to my script"
else
  echo "Sorry, too slow! "
fi
```

#### Ввод паролей

Ключ -s команды read предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда read делает цвет текста таким же, как цвет фона.

```bash
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
```

#### Чтение данных из файла

```bash
#!/bin/bash
count=1
cat myfile | while read line
  do
    echo "Line $count: $line"
    count=$(( $count + 1 ))
  done
echo "Finished"
```

### Bash-скрипты, часть 4: ввод и вывод

#### Стандартные дескрипторы файлов

Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают.

- 0, STDIN — стандартный поток ввода.
- 1, STDOUT — стандартный поток вывода.
- 2, STDERR — стандартный поток ошибок.

#### STDIN

`STDIN` — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура. Когда в сценариях используют символ перенаправления ввода — `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.

Многие команды bash принимают ввод из `STDIN`, если в командной строке не указан файл, из которого надо брать данные. Например, это справедливо для команды `cat`.

Когда вы вводите команду cat в командной строке, не задавая параметров, она принимает ввод из `STDIN`. После того, как вы вводите очередную строку, cat просто выводит её на экран.

#### STDOUT

`STDOUT` — стандартный поток вывода оболочки. По умолчанию это — экран. Большинство bash-команд выводят данные в `STDOUT`, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`.

Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:

`pwd >> myfile`

То, что выведет `pwd`, будет добавлено к файлу `myfile`, при этом уже имеющиеся в нём данные никуда не денутся.

Пока всё хорошо, но что если попытаться выполнить что-то вроде показанного ниже, обратившись к несуществующему файлу `xfile`, задумывая всё это для того, чтобы в файл `myfile` попало сообщение об ошибке.

`ls –l xfile > myfile`

После выполнения этой команды мы увидим сообщения об ошибках на экране.

При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но мы-то хотели, чтобы сообщения об ошибках попали в файл. Что делать? Ответ прост — воспользоваться третьим стандартным дескриптором.

#### STDERR

`STDERR` представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`, именно поэтому при возникновении ошибки мы видим сообщение на экране.

▍Перенаправление потока ошибок

Итак, предположим, что надо перенаправить сообщения об ошибках, скажем, в лог-файл, или куда-нибудь ещё, вместо того, чтобы выводить их на экран.

Как вы уже знаете, дескриптор файла `STDERR` — 2. Мы можем перенаправить ошибки, разместив этот дескриптор перед командой перенаправления:

```bash
ls -l xfile 2>myfile
cat ./myfile
```

Сообщение об ошибке теперь попадёт в файл `myfile`

▍Перенаправление потоков ошибок и вывода

При написании сценариев командной строки может возникнуть ситуация, когда нужно организовать и перенаправление сообщений об ошибках, и перенаправление стандартного вывода. Для того, чтобы этого добиться, нужно использовать команды перенаправления для соответствующих дескрипторов с указанием файлов, куда должны попадать ошибки и стандартный вывод:

```bash
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
```

Оболочка перенаправит то, что команда `ls` обычно отправляет в `STDOUT`, в файл `correctcontent` благодаря конструкции `1>`. Сообщения об ошибках, которые попали бы в `STDERR`, оказываются в файле `errorcontent` из-за команды перенаправления `2>`.

Если надо, и `STDERR`, и `STDOUT` можно перенаправить в один и тот же файл, воспользовавшись командой `&>`

```bash
ls –l myfile xfile anotherfile &> correctcontent
```

#### Перенаправление вывода в скриптах

Существует два метода перенаправления вывода в сценариях командной строки:

- Временное перенаправление, или перенаправление вывода одной строки.
- Постоянное перенаправление, или перенаправление всего вывода в скрипте либо в какой-то его части.

▍Временное перенаправление вывода

В скрипте можно перенаправить вывод отдельной строки в STDERR. Для того, чтобы это сделать, достаточно использовать команду перенаправления, указав дескриптор STDERR, при этом перед номером дескриптора надо поставить символ амперсанда (&):

```bash
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
This is an error
This is normal output
```

Запустим скрипт так, чтобы вывод STDERR попадал в файл.

`./myscript 2> myfile`

Как видно, теперь обычный вывод делается в консоль, а сообщения об ошибках попадают в файл.

▍Постоянное перенаправление вывода

Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову echo неудобно. Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой `exec`:

```bash
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
```

всё, что выводилось командами echo, попало в файл.


Команду exec можно использовать не только в начале скрипта, но и в других местах:

```bash
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
```

#### Перенаправление ввода в скриптах

Для перенаправления ввода можно воспользоваться той же методикой, которую мы применяли для перенаправления вывода. Например, команда exec позволяет сделать источником данных для STDIN какой-нибудь файл:

`exec 0< myfile`

Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл myfile, а не обычный STDIN. Посмотрим на перенаправление ввода в действии:

```bash
#!/bin/bash
exec 0< testfile
count=1
while read line
  do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
  done
```

#### Создание собственного перенаправления вывода

Перенаправляя ввод и вывод в сценариях, вы не ограничены тремя стандартными дескрипторами файлов. Как уже говорилось, можно иметь до девяти открытых дескрипторов. Остальные шесть, с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

Назначить дескриптор для вывода данных можно, используя команду `exec`:

```bash
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
```

#### Создание дескрипторов файлов для ввода данных

После окончания чтения файла можно восстановить STDIN и пользоваться им как обычно:

```bash
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line
  do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
  done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
  y) echo "Goodbye";;
  n) echo "Sorry, this is the end.";;
esac
```

#### Закрытие дескрипторов файлов

Оболочка автоматически закрывает дескрипторы файлов после завершения работы скрипта. Однако, в некоторых случаях нужно закрывать дескрипторы вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть дескриптор, его нужно перенаправить в &-. Выглядит это так:

```bash
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
```

мы попытались обратиться к несуществующему дескриптору.

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
./linux/2bash_sckr: line 6: 3: Bad file descriptor
```

#### Получение сведений об открытых дескрипторах

Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой `lsof`. Во многих дистрибутивах, вроде Fedora, утилита `lsof` находится в /usr/sbin. Эта команда весьма полезна, так как она выводит сведения о каждом дескрипторе, открытом в системе. Сюда входит и то, что открыли процессы, выполняемые в фоне, и то, что открыто пользователями, вошедшими в систему.

У этой команды есть множество ключей, рассмотрим самые важные.

- `-p` Позволяет указать ID процесса.
- `-d` Позволяет указать номер дескриптора, о котором надо получить сведения.

Для того, чтобы узнать PID текущего процесса, можно использовать специальную переменную окружения $$, в которую оболочка записывает текущий PID.

Ключ -a используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей:

`lsof -a -p $$ -d 0,1,2`

Тип файлов, связанных с STDIN, STDOUT и STDERR — CHR (character mode, символьный режим). Так как все они указывают на терминал, имя файла соответствует имени устройства, назначенного терминалу. Все три стандартных файла доступны и для чтения, и для записи.

Посмотрим на вызов команды lsof из скрипта, в котором открыты, в дополнение к стандартным, другие дескрипторы:

```bash
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
./linux/2bash_sckr: line 5: myfile3: No such file or directory
COMMAND       PID USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
2bash_sck 1480471 dima    0u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    1u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    2u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    3w   REG   8,17        0 42751766 /home/dima/javascript/projects/1test/myfile1
2bash_sck 1480471 dima    6w   REG   8,17        0 42751767 /home/dima/javascript/projects/1test/myfile2
```

#### Подавление вывода

Иногда надо сделать так, чтобы команды в скрипте, который, например, может исполняться как фоновый процесс, ничего не выводили на экран. Для этого можно перенаправить вывод в /dev/null. Это — что-то вроде «чёрной дыры».

Вот, например, как подавить вывод сообщений об ошибках:

`ls -al badfile anotherfile 2> /dev/null`

Тот же подход используется, если, например, надо очистить файл, не удаляя его:

`cat /dev/null > myfile`

### часть 5: сигналы, фоновые задачи, управление сценариями

как скрипт может работать с сигналами Linux, о различных подходах к запуску скриптов и к управлению ими во время работы.

#### Сигналы Linux

Код сигнала      Название    Описание
 1	              SIGHUP	Закрытие терминала
 2	              SIGINT	Сигнал остановки процесса пользователем с терминала (CTRL + C)
 3	              SIGQUIT	Сигнал остановки процесса пользователем с терминала (CTRL + \) с дампом памяти
 9	              SIGKILL	Безусловное завершение процесса
 15	              SIGTERM	Сигнал запроса завершения процесса
 17	              SIGSTOP	Принудительная приостановка выполнения процесса, но не завершение его работы
 18	              SIGTSTP	Приостановка процесса с терминала (CTRL + Z), но не завершение работы
 19	              SIGCONT	Продолжение выполнения ранее остановленного процесса



### expect

#### Основы expect

`$ apt-get install expect`

основные команды:

- `spawn` — запуск процесса или программы. Например, это может быть командная оболочка, FTP, Telnet, ssh, scp и так далее.

- `expect` — ожидание данных, выводимых программой. При написании скрипта можно указать, какого именно вывода он ждёт и как на него нужно реагировать.
- `send` — отправка ответа. Expect-скрипт с помощью этой команды может отправлять входные данные автоматизируемой программе. Она похожа на знакомую вам команду echo в обычных bash-скриптах.
- `interact` — позволяет переключиться на «ручной» режим управления программой.

#### Автоматизация bash-скрипта

скрипт, который взаимодействует с пользователем и автоматизируем его с помощью expect.

    ./qestions.sh
    #!/bin/bash
    echo "Hello, who are you?"
    read $REPLY
    echo "Can I ask you some questions?"
    read $REPLY
    echo "What is your favorite topic?"
    read $REPLY

expect-скрипт, который запустит скрипт questions и будет отвечать на его вопросы:

    ./answerbot.exp
    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Im Adam\r"
    expect "Can I ask you some questions?\r"
    send -- "Sure\r"
    expect "What is your favorite topic?\r"
    send -- "Technology\r"
    expect eof

В начале скрипта находится строка идентификации, которая, в данном случае, содержит путь к expect, так как интерпретировать скрипт будет именно expect.
Во второй строке мы отключаем тайм-аут, устанавливая переменную expect timeout в значение -1. Остальной код — это и есть автоматизация работы с bash-скриптом.

Сначала, с помощью команды spawn, мы запускаем bash-скрипт. Естественно, тут может быть вызвана любая другая утилита командной строки. Далее задана последовательность вопросов, поступающих от bash-скрипта, и ответов, которые даёт на них expect. Получив вопрос от подпроцесса, expect выдаёт ему заданный ответ и ожидает следующего вопроса.

В последней команде expect ожидает признака конца файла, скрипт, дойдя до этой команды, завершается.

`$ chmod +x ./answerbot.exp`
`$ chmod +x ./qestions.sh`

запускаем

`$./answerbot.exp`

узнать где expect

`$ which expect`

#### Autoexpect — автоматизированное создание expect-скриптов

Autoexpect позволяет запускать программы, которые надо автоматизировать, после чего записывает то, что они выводят, и то, что пользователь вводит, отвечая на их вопросы. Вызовем autoexpect, передав этой утилите имя нашего скрипта:

`$ autoexpect ./questions.sh`

отвечаем на вопросы questions.sh

После завершения работы с bash-скриптом, autoexpect сообщит о том, что собранные данные записаны в файл script.exp. Если запустить этот скрипт, результат будет тем же.

При записи сеансов взаимодействия с некоторыми программами, вроде FTP-клиентов, вы можете столкнуться с тем, что они используют в выводимых данных сведения о времени проведения операции, или выводят данные, отражающие процесс выполнения неких продолжительных действий. В целом, речь идёт о том, что вывод программы при каждом её запуске, правильно воспринимаемый человеком и вызывающий ввод одних и тех же ответов, будет, в тех же условиях, выглядеть по-новому для expect.

Если в expect-скрипте строки, ожидаемые от такой программы, будут жёстко зафиксированы, такой скрипт не сможет нормально работать. Справиться с этим можно, либо удалив из expect-скрипта данные, которые выглядят по-новому при каждом запуске программы, либо использовав шаблоны, пользуясь которыми, expect сможет правильно понять то, что хочет от него программа.

#### Работа с переменными и параметрами командной строки

Для объявления переменных в expect-скриптах используется команда set. Например, для того, чтобы присвоить значение 5 переменной VAR1, используется следующая конструкция:

`set VAR1 5`

Для доступа к значению переменной перед её именем надо добавить знак доллара — $. В нашем случае это будет выглядеть как $VAR1.

Для того, чтобы получить доступ к аргументам командной строки, с которыми вызван expect-скрипт, можно поступить так:

`set VAR [lindex $argv 0]`

Тут мы объявляем переменную `VAR` и записываем в неё указатель на первый аргумент командной строки, `$argv 0`.

Отредактируем скрипт answerbot, приведя его к такому виду:

    ./answerbot.exp
    #!/usr/bin/expect -f
    set my_name [lindex $argv 0]
    set my_favorite [lindex $argv 1]
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Im $my_name\r"
    expect "Can I ask you some questions?\r"
    send -- "Sure\r"
    expect "What is your favorite topic?\r"
    send -- "$my_favorite\r"
    expect eof

Запустим его, передав в качестве первого параметра SomeName, в качестве второго — Programming:

`$ ./answerbot SomeName Programming`

expect-скрипт отвечает на вопросы bash-скрипта, пользуясь переданными ему параметрами командной строки.

#### Ответы на разные вопросы, которые могут появиться в одном и том же месте

Если автоматизируемая программа может, в одной ситуации, выдать одну строку, а в другой, в том же самом месте — другую, в expect можно использовать блоки, заключённые в фигурные скобки и содержащие варианты реакции скрипта на разные данные, полученные от программы

Напишем новый скрипт, записав его в файл questions, случайным образом задающий в одном и том же месте разные вопросы:

    #!/bin/bash
    let number=$RANDOM
    if [ $number -gt 25000 ]
    then
    echo "What is your favorite topic?"
    else
    echo "What is your favorite movie?"
    fi
    read $REPLY

Тут мы генерируем случайное число при каждом запуске скрипта, и, проанализировав его, выводим один из двух вопросов.

Для автоматизации такого скрипта нам и пригодится вышеописанная конструкция:

    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect {
        "*topic?" { send -- "Programming\r" }
        "*movie?" { send -- "Star wars\r" }
    }

#### Условный оператор

использования условного оператора:

    #!/usr/bin/expect -f
    set TOTAL 1
    if { $TOTAL < 5 } {
    puts "\nTOTAL is less than 5\n"
    } elseif { $TOTAL > 5 } {
    puts "\nTOTAL greater than 5\n"
    } else {
    puts "\nTOTAL is equal to 5\n"
    }
    expect eof

`puts "text"` выводит text в консоль

Тут мы присваиваем переменной TOTAL некое число, после чего проверяем его и выводим текст, зависящий от результата проверки.

Обратите внимание на конфигурацию фигурных скобок. Очередная открывающая скобка должна быть расположена на той же строке, что и предыдущие конструкции.

#### Цикл while

Циклы while в expect очень похожи на те, что используются в обычных bash-скриптах, но, опять же, тут применяются фигурные скобки:

    #!/usr/bin/expect -f
    set COUNT 0
    while { $COUNT <= 5 } {
    puts "\nCOUNT is currently at $COUNT"
    set COUNT [ expr $COUNT + 1 ]
    }
    puts ""

Цикл for

Цикл for в expect устроен по-особому. В начале цикла, в самостоятельных парах фигурных скобок, надо указать переменную-счётчик, условие прекращения цикла и правило модификации счётчика. Затем, опять же в фигурных скобках, идёт тело цикла:

    #!/usr/bin/expect -f
    for {set COUNT 0} {$COUNT <= 5} {incr COUNT} {
    puts "\nCOUNT is at $COUNT"
    }
    puts ""

#### Объявление и использование функций

Expect позволяет программисту объявлять функции, используя ключевое слово proc:

    #!/usr/bin/expect -f

    proc myfunc { MY_COUNT } {
    set MY_COUNT [expr $MY_COUNT + 1]
    return "$MY_COUNT"
    }

    set COUNT 0
    while {$COUNT <= 5} {
    puts "\nCOUNT is currently at $COUNT"
    set COUNT [myfunc $COUNT]
    }
    puts ""

## Команда interact

Случается так, что автоматизируемые с помощью expect программы требуют ввода конфиденциальных данных, вроде паролей, которые вам не хотелось бы хранить в виде обычного текста в коде скрипта. В подобной ситуации можно воспользоваться командой interact, которая позволит вам, автоматизировав некую часть взаимодействия с программой, самостоятельно ввести, скажем, пароль, а потом опять передать управление expect.

Напишем expect-скрипт, который, когда ему предлагают предоставить пароль, передаёт управление нам:

    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Hi Im Adam\r"
    expect "*password?\r"
    interact ++ return
    send "\r"
    expect "*topic?\r"
    send -- "Technology\r"
    expect eof

Встретив команду interact, expect-скрипт остановится, предоставив нам возможность ввести пароль. После ввода пароля надо ввести «++» и expect-скрипт продолжит работу, снова получив управление.

## tee

команда tee linux принимает данные из одного источника и может сохранять их на выходе в нескольких местах

### Синтаксис команды tee

```bash
tee опции файл
```

- `-a` или `-append` - Используется для записи вывода в конец существующего файла.
- `-i` или `-ignore-interrupts` - Используется, чтобы игнорировать прерывающие сигналы.
- `-help` - Используется для показа всех возможных операций.
- `-version` - Используется для показа текущей версии этой команды.

### 1. Простое использование команды tee

первая команда показала вывод списка файлов в текущем каталоге в терминал и записала полученные данные в файл вывод.txt, Вторая команда показала содержимое файла вывод.txt

```bash
ls -la | tee вывод.txt
cat вывод.txt
```

### 2. Добавление вывода в существующий файл

команда отображает вывод pwd в терминал и записывает вывод в конец файла вывод.txt

```bash
pwd | tee -a вывод.txt
```

### 3. Запись вывода в несколько файлов

```bash
date | tee вывод1.txt вывод2.txt
```

### 4. Игнорируем прерывание сигнала

ee linux с опцией -i используется в этом примере, чтобы игнорировать любые прерывания во время ее выполнения. Таким образом, команда будет выполнена правильно, даже если пользователь нажимает CTRL+C

первая команда считает количество строчек в файле вывод.txt и сохраняет полученный результат в файл вывод3.txt Вторая команда показывает содержимое файла вывод.txt, который содержит 37 строчек. Третья команда показывает содержимое файла вывод3.txt, в котором указано, что он действительно содержит 37 строчек

```bash
wc -l вывод.txt | tee -i вывод3.txt
cat вывод.txt
cat вывод3.txt
```

### 5. Перенос вывода команды tee в другую команду

Вывод команды tee может быть перенесен в другую команду. В этом примере вывод из первой команды переносится в tee, а ее вывод — в другую команду

```bash
ls | tee вывод4.txt | wc -lcw
```

Здесь первая команда используется для записи вывода ls в файл вывод4.txt и подсчета общего числа строк, слов и символов в файле вывод4.txt

### 6. Команда tee и скрипты

./add.sh
```bash
#!/bin/bash
a=$1
b=$2
((result=$a+$b))
echo "The addition of $a+$b=$result"
```

```bash
bash add.sh 40 80 | tee результат.txt
```

Здесь числа 40 и 80 переносятся в качестве аргументов командной строки в скрипт add.sh и вывод записывается в файл результат.txt 

### 7. Как скрыть вывод команды в терминале

команда используется для записи вывода команды df в файл вывод5.txt, при этом вывод не показывается в терминале

```bash
df | tee вывод5.txt > /dev/null
```

## ln

Команда ln в операционных системах, разработанных на основе ядра Linux, используется для создания символических и жестких ссылок на файлы.

### Ссылки на файл в Linux

#### Символические ссылки

Символическая ссылка — файл определенного типа, который выступает в роли линка на другой объект — файл любого формата или определенный каталог. Обычно такие объекты называют целевыми. Иногда вы можете заметить, что такой тип ссылок называют soft links или sym-link. Такой элемент не содержит в себе данных цели, а лишь выступает указателем, то есть является полной копией ярлыка из Виндовс. Внутри symbolic link находится только путь. Никто не запрещает вам создать множество подобных линков с разными именами, но одним и тем же целевым объектом. Связь между двумя составляющими называется мягкой, поскольку при удалении ссылки целевой файл никаким образом не страдает. Однако при удалении файла ссылка становится нерабочей. Она сохраняется на диске, но указанный в ней путь ведет уже к несуществующему объекту.

![soft links](images/links-1.drawio.svg)

эту ссылку можно перемещать в любое место на компьютере, от этого не зависит ее работоспособность, ведь она будет переходить по тому же пути, который был указан при создании.

#### Жесткие ссылки

Они, по сути, синонимы файла, но при этом не его копии. При создании жесткой ссылки будет сгенерирован еще один указатель на элемент. дела обстоят немного сложнее. Они, по сути, синонимы файла, но при этом не его копии. При создании жесткой ссылки будет сгенерирован еще один указатель на элемент. В файловой системе такие объекты определяются как еще один файл, поэтому при создании их в одной и той же директории с целью нельзя указывать одинаковое с ней имя. Все жесткие линки на файл должны находиться в одной ФС и не могут быть присвоены каталогу или несуществующему элементу.

![hard link](images/links-h.drawio.svg)

Важно отметить, что линк будет иметь точно такой же идентификатор (inode), как и целевой файл. Как известно, у всех объектов свои уникальные номера. Из-за этого между ними будет различие только в именах. Все права, владелец и даты изменений сохраняются. Можно сказать, что жесткая ссылка — еще одно название для объекта. При удалении целевого файла линк все равно будет хранить информацию, которая находилась в нем, поскольку на содержимое остается еще один указатель.

#### Создание ссылок

##### Символическая ссылка

```bash
ln -s file slink
```

 где file — имя или полный путь к файлу или директории, а slink — название ссылки. Она будет помещена в тот же каталог, где и находится целевой объект.

```bash
ls -li
```

 чтобы увидеть информацию по поводу находящихся в каталоге объектов.

#####  Жёстка ссылка

```bash
ln file hlink
```

## Что означает число в скобках, указанное после имен команд Unix в manpages?

Например: `man(1)`, `find(3)`, `updatedb(2)`?

Это раздел, которому назначена man-страница для команды.

Они разделены следующим образом

1. Общие команды
2. Системные вызовы
3. Функции библиотеки C
4. Специальные файлы (обычно устройства, которые находятся в /dev) и драйверы
5. Форматы файлов и соглашения
6. Игры и заставки
7. Сборник
8. Команды и демоны системного администрирования

Оригинальные описания каждого раздела можно увидеть в [Руководстве программиста Unix](https/web.archive.org/web/20170601064537/http://plan9.bell-labs.com/7thEdMan/v7vol1.pdf) (страница ii).

Чтобы получить доступ к справочной странице, заданной как "foo (5)", запустите:

`man 5 foo`

## Cron

### Как работает Cron?

сервис запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл `/etc/crontab`, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты run-parts, которая запускает нужные скрипты из следующих папок:

- `/etc/cron.minutely` - каждую минуту;
- `/etc/cron.hourly` - каждый час;
- `/etc/cron.daily` - каждый день;
- `/etc/cron.weekly` - каждую неделю;
- `/etc/cron.monthly` - каждый месяц.

В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле crontab прописан запуск команды anacron, которая работает так же как и cron, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.

Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл /var/spool/anacron, а затем, при следующем запуске anacron проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.

### Настройка Cron

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла cron и специальная команда. Конечно, вы всегда можете отредактировать файл /etc/crontab, но этого делать не рекомендуется. Вместо этого, есть команда crontab:

```bash
crontab -e
```

Ее всегда желательно выполнять с опцией -e, тогда для редактирования правил будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл, в котором уже представлены все текущие правила cron и вы можете добавить новые. После завершения работы команды cron файл будет обработан и все правила будут добавлены в /var/spool/cron/crontabs/имя_пользователя причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.

Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и crontab нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

### Синтаксис crontab

```bash
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly>
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthl>
```

Нужно сказать, что обязательно нужно писать полный путь к команде, потому что для команд, запускаемых от имени cron переменная среды PATH будет отличаться, и сервис просто не сможет найти вашу команду. Это вторая самая распространенная причина проблем с Cron. Дата и время указываются с помощью цифр или символа '*'. Этот символ означает, что нужно выполнять каждый раз, если в первом поле - то каждую минуту и так далее. Ну а теперь перейдем к примерам.

### Примеры настройки cron

Сначала можно посмотреть задачи cron для суперпользователя, для этого можно воспользоваться опцией -l:

```bash
crontab -l
```

Вы можете удалить все существующие задачи командой -r:

```bahs
crontab -r
```

Давайте предположим, что нам нужно запускать от имени суперпользователя наш скрипт по адресу /usr/local/bin/serve. Какой-нибудь обслуживающий скрипт. Самый простой пример - запускать его каждую минуту:

`* * * * * /usr/local/bin/serve`

Далее, усложним, будем запускать каждый час, в нулевую минуту:

`0 * * * * /usr/local/bin/serve`

Запускаем в нулевую минуту нулевого часа, каждый день, это в 12 ночи:

`0 0 * * * /usr/local/bin/serve`

в первый день каждого месяца:

`0 0 1 * * /usr/local/bin/serve`

Можно в любой день, например, 15 числа:

`0 0 15 * * /usr/local/bin/serve`

В первый день недели первого месяца года, 0 часов 0 минут:

`0 0 * 1 0 /usr/local/bin/serve`

Или в нулевой день недели каждого месяца:

`0 0 * * 0 /usr/local/bin/serve`

Вы можете выбрать любую минуту, час и день недели, например, 15.30 во вторник:

`30 15 * * 2 /usr/local/bin/serve`

Понедельник считается первым днем, воскресенье - это седьмой или нулевой день. Еще можно писать сокращенное название дня недели, например sun - воскресенье:

`30 15 * * sun /usr/local/bin/serve`

Для того чтобы указать определенный интервал нужно использовать символ "-", например, каждый час, с семи утра до семи вечера:

`0 7-19  * * * /usr/local/bin/serve`

Если нужно запустить команду несколько раз, можно использовать разделитель ",". Например, запустим скрипт в 5 и 35 минут пятого (16:05 и 16:35), каждый день:

`5,35 16  * * * /usr/local/bin/serve`

Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, раз в 10 минут. Для этого используется разделитель косая черта - "/":

`*/10 * * * * /usr/local/bin/serve`

Кроме того, для некоторых часто используемых наборов были придуманы переменные, вот они:

`@reboot` - при загрузке, только один раз;
`@yearly`, @annually - раз год;
`@monthly` - раз в месяц;
`@weekly` - раз в неделю;
`@daily`, @midnight - каждый день;
`@hourly` - каждый час.

Например, вот так просто будет выглядеть команда запуска скрипта раз в час:

`@hourly /usr/local/bin/serve`

Если же вы собрались добавить скрипт в одну из папок, то, как я уже говорил, нужно чтобы его имя было без точек и у него были права на выполнение:

```bash
sudo vi /etc/cron.daily/backup

#!/bin/bash
......
```

### Отладка работы

После того как вы настроили правила, еще хотелось бы проверить работают ли они. Для этого ждем того времени, когда скрипт уже должен быть выполнен и смотрим лог cron. Иногда он находится в /var/log/cron, а иногда пишется в syslog. Например, у меня в crontab есть такая строка:

`40 19 * * * /usr/bin/ucaresystem-core`

Она должна выполняться в 19.40 каждый день, теперь смотрим лог:

`grep CRON /var/log/syslog`

```bash
Oct 14 00:17:01 dima-Nitro-AN515-52 CRON[601716]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 01:17:01 dima-Nitro-AN515-52 CRON[664626]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 08:17:01 dima-Nitro-AN515-52 CRON[696285]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 08:30:01 dima-Nitro-AN515-52 CRON[709713]: (root) CMD ([ -x /etc/init.d/anacron ] && if [ ! -d /run/systemd/system ]; then /usr/sbin/invoke-rc.d anacron start >/dev/null; fi)
Oct 14 19:07:01 dima-Nitro-AN515-52 CRON[713267]: (root) CMD (   test -x /etc/cron.daily/popularity-contest && /etc/cron.daily/popularity-contest --crond)
Oct 14 19:17:01 dima-Nitro-AN515-52 CRON[724460]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 19:30:02 dima-Nitro-AN515-52 CRON[738558]: (root) CMD ([ -x /etc/init.d/anacron ] && if [ ! -d /run/systemd/system ]; then /usr/sbin/invoke-rc.d anacron start >/dev/null; fi)
Oct 14 20:17:02 dima-Nitro-AN515-52 CRON[791555]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 20:20:01 dima-Nitro-AN515-52 CRON[795003]: (dima) CMD (echo 'my coron command' >> /home/dima/test_cron.txt)
Oct 14 20:21:01 dima-Nitro-AN515-52 CRON[796158]: (dima) CMD (echo 'my coron command' >> /home/dima/test_cron.txt)
```

И видим что в нашем логе она действительно есть и выполняется целиком успешно. Если бы были какие-либо ошибки, то тут же было бы выведено сообщение.

Если нужно проверить скрипт, который находится в одной из специализированных папок, то тут еще проще, просто запустите run-paths, передав ей в параметр нужную папку или даже сам скрипт:

`sudo run-parts /etc/cron.daily/`

