# Linux

## Операторы объединения команд в Linux & | ; && ! || &&-|| \ ()

### Оператор амперсанда (&)

& — команда выполняется в фоновом режиме. Нужно ввести команду с пробелом и ‘&‘. Можно выполнить более одной команды в фоновом режиме за один раз.

`ping c5 disweb.ru &`

Запуск двух команд в фоновом режиме одновременно:

`sudo apt update & sudo apt upgrade &`

### Оператор точка с запятой (;)

Оператор точка с запятой позволяет запускать несколько команд за один раз, и выполнение команды происходит последовательно.

`sudo apt update ; sudo apt upgrade ; mkdir test`

### Оператор AND (&&)

Оператор AND (&&) будет выполнять вторую команду только в том случае, если при выполнении первой команды SUCCEEDS, т.е. состояние выхода первой команды равно «0» — программа выполнена успешно. Эта команда очень полезна при проверке состояния выполнения последней команды.

Например, я хочу посетить сайт sedicomm.com с помощью команды links в терминале, но перед этим мне нужно проверить, является ли хост доступным или нет.

`ping -c3 www.sedicomm.com && links www.sedicomm.com`

### Оператор OR (||)

Оператор OR (||) очень похож на оператор «else» в программировании. Вышеуказанный оператор позволяет вам выполнять вторую команду только в случае сбоя при выполнении первой команды, то есть состояние выхода первой команды равно «1» — программа выполнена НЕ успешно».

Например, я хочу выполнить «apt-get update» из учетной записи без полномочий root, и если первая команда не будет выполнена, тогда будет выполнена вторая команда «links <www.sedicomm.com»>.

`sudo apt update || links sedicomm.com`

Что, если первая команда выполнена успешно, со статусом выхода «0«? Очевидно! Вторая команда не будет выполнена.

`mkdir test || links sedicomm.com`

### Оператор NOT (!)

Оператор NOT (!) очень похож на оператор «кроме«. Эта команда выполнит все, кроме предоставленного условия. Чтобы понять как это работает, создайте каталог «sedicomm» в вашем домашнем каталоге и перейдите к нему с помощью команды «cd«.

`mkdir sedicomm`
`cd sedicomm`

Затем создайте несколько типов файлов в папке «sedicomm».

`touch a.doc b.doc a.pdf b.pdf a.xml b.xml a.html b.html`

Смотрите, мы создали все новые файлы в папке «sedicomm».

`ls a.doc a.html a.pdf a.xml a.doc b.html b.pdf b.xml`

Теперь удалите все файлы, за исключением файла «html»одновременно, умным способом.

`rm -r !(*.html)`

Просто чтобы проверить, последнее исполнение. Перечислите все доступные файлы с помощью команды ls.

`ls a.html b.html`

### Оператор AND-OR (&& — ||)

Вышеуказанный оператор фактически является комбинацией оператора «AND» и «OR». Это очень похоже на утверждение «если-еще».

Например, давайте сделаем ping на disweb.ru, если успешно то выведем на экран ‘Verified‘, если ping не успешный, то выведен на экран ‘Host Down‘.

`ping -c3 disweb.ru && echo "Verified" || echo "Host Down"`

Пример вывода

PING disweb.ru (62.109.11.132) 56(84) bytes of data.
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=1 ttl=61 time=0.906 ms
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=2 ttl=61 time=0.800 ms
64 bytes from srv1.hoverhost.ru (62.109.11.132): icmp_seq=3 ttl=61 time=0.791 ms

--- disweb.ru ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 0.791/0.832/0.906/0.057 ms
Verified

### Оператор потока PIPE (|)

Этот оператор потока PIPE очень полезен, когда выходные данные первой команды действуют как входные данные для второй команды. Например, направьте вывод команды «ls -l» на «less» и посмотрите вывод всего скрипта.

`ls -l | less`

### Оператор комбинации команд {}

Объедините две или более команд, вторая команда зависит от выполнения первой команды.

Например, проверьте, доступен ли каталог «bin», и выведите соответствующий вывод.

`[ -d"bin" ] || { echo Directory does not exist, creating directory now.; mkdir bin; } && echo Directory exists.`

### Оператор приоритета ()

Оператор позволяет выполнить команду в порядке приоритета.

`Command_x1 && Command_x2 || Command_x3 && Command_x4`

В приведенной выше псевдокоманде, что если Command_x1 завершится неудачно? Ни один из Command_x2, Command_x3, Command_x4 не будет выполнен, для этого мы используем оператор приоритета вот так:

`(Command_x1 && Command_x2) || (Command_x3 && Command_x4)`

В вышеприведенном скрипте, если Command_x1 завершается ошибкой, Command_x2 также завершается ошибкой, но все же выполнение Command_x3 и Command_x4 зависит от состояния выхода Command_x3.

### Оператор конкатенации (\)

Оператор конкатенации (\), как указывает имя, используется для объединения больших команд в нескольких строках оболочки. Например, команда ниже откроет текстовый файл test(1).txt.

`nano test\(1\).txt`

## Перенаправление ввода/вывода в Linux

### Потоки

Стандартный ввод при работе пользователя в терминале передается через клавиатуру.

Стандартный вывод и стандартная ошибка отображаются на дисплее терминала пользователя в виде текста.

Ввод и вывод распределяется между тремя стандартными потоками:

- stdin — стандартный ввод (клавиатура),
- stdout — стандартный вывод (экран),
- stderr — стандартная ошибка (вывод ошибок на экран).

Потоки также пронумерованы:

- stdin — 0,
- stdout — 1,
- stderr — 2.

Из стандартного ввода команда может только считывать данные, а два других потока могут использоваться только для записи. Данные выводятся на экран и считываются с клавиатуры, так как стандартные потоки по умолчанию ассоциированы с терминалом пользователя. Потоки можно подключать к чему угодно: к файлам, программам и даже устройствам. В командном интерпретаторе bash такая операция называется перенаправлением:

- `< file` — использовать файл как источник данных для стандартного потока ввода.
- `> file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- `2> file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
- `>>file` — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- `2>>file` — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
- `&>file` или `>&file` — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: `>file 2>&1`.

### Стандартный ввод

Стандартный входной поток обычно переносит данные от пользователя к программе. Программы, которые предполагают стандартный ввод, обычно получают входные данные от устройства типа клавиатура. Стандартный ввод прекращается по достижении EOF (конец файла), который указывает на то, что данных для чтения больше нет.

EOF вводится нажатием сочетания клавиш `Ctrl+D`.

Рассмотрим работу со стандартным выводом на примере команды `cat` (от CONCATENATE, в переводе «связать» или «объединить что-то»).

**Cat** обычно используется для объединения содержимого двух файлов.

**Cat** отправляет полученные входные данные на дисплей терминала в качестве стандартного вывода и останавливается после того как получает EOF.

В открывшейся строке введите, например, 1 и нажмите клавишу Enter. На дисплей выводится 1. Введите a и нажмите клавишу Enter. На дисплей выводится a.

Дисплей терминала выглядит следующим образом:

    test@111:~/stream$ cat
    1
    1
    a
    a

Для завершения ввода данных следует нажать сочетание клавиш Ctrl + D.

### Стандартный вывод

Стандартный вывод записывает данные, сгенерированные программой. Когда стандартный выходной поток не перенаправляется в какой-либо файл, он выводит текст на дисплей терминала.

При использовании без каких-либо дополнительных опций, команда echo выводит на экран любой аргумент, который передается ему в командной строке:

    echo Пример

Аргументом является то, что получено программой, в результате на дисплей терминала будет выведено:

    Пример

Команда объединяет три файла: file1, file2 и file3 в один файл bigfile:

    cat file1 file1 file1 > bigfile

### Стандартная ошибка

Стандартная ошибка записывает ошибки, возникающие в ходе исполнения программы. Как и в случае стандартного вывода, по умолчанию этот поток выводится на терминал дисплея.

При запуске без аргументов ls выводит содержимое в пределах текущего каталога.

Введем команду ls с каталогом % в качестве аргумента:

    ls %

В результате должно выводиться содержимое соответствующей папки. Но так как каталога % не существует, на дисплей терминала будет выведен следующий текст стандартной ошибки:

    ls: cannot access %: No such file or directory

### Перенаправление потока

Linux включает в себя команды перенаправления для каждого потока.

Команды со знаками > или < означают перезапись существующего содержимого файла:

- `>` — стандартный вывод,
- `<` — стандартный ввод,
- `2>` — стандартная ошибка.

Команды со знаками >> или << не перезаписывают существующее содержимое файла, а присоединяют данные к нему:

- `>>` — стандартный вывод,
- `<<` — стандартный ввод,
- `2>>` — стандартная ошибка.

В приведенном примере команда cat используется для записи в файл file1, который создается в результате цикла:

    cat > file1
    a
    b
    c

Для завершения цикла нажмите сочетание клавиш Ctrl + D.

Если файла file1 не существует, то в текущем каталоге создается новый файл с таким именем.

Для просмотра содержимого файла file1 введите команду:

    cat file1

В результате на дисплей терминала должно быть выведено следующее:

    a
    b
    c

Для перезаписи содержимого файла введите следующее:

    cat > file1
    1
    2
    3

Для завершения цикла нажмите сочетание клавиш `Ctrl + D`.

В результате на дисплей терминала должно быть выведено следующее:

      1
      2
      3

Предыдущего текста в текущем файле больше не существует, так как содержимое файла было переписано командой `>`.

Для добавления нового текста к уже существующему в файле с помощью двойных скобок `>>` выполните команду:

    cat >> file1
    a
    b
    c

Для завершения цикла нажмите сочетание клавиш Ctrl + D.

Откройте `file1` снова и в результате на дисплее монитора должно быть отражено следующее:

    1
    2
    3
    a
    b
    c

### Каналы

Каналы используются для перенаправления потока из одной программы в другую. Стандартный вывод данных после выполнения одной команды перенаправляется в другую через канал. Данные первой программы, которые получает вторая программа, не будут отображаться. На дисплей терминала будут выведены только отфильтрованные данные, возвращаемые второй командой.

Введите команду:

    ls | less

В результате каждый файл текущего каталога будет размещен на новой строке:

    file1
    file2
    t1
    t2

Перенаправлять данные с помощью каналов можно как из одной команды в другую, так и из одного файла к другому, а перенаправление с помощью > и >> возможно только для перенаправления данных в файлах.

Для сохранения имен файлов, содержащих строку «LOG», используется следующая команда:

    dir /catalog | find "LOG" > loglist

Вывод команды dir отсылается в команду-фильтр find. Имена файлов, содержащие строку «LOG», хранятся в файле loglist в виде списка (например, Config.log, Logdat.svd и Mylog.bat).

При использовании нескольких фильтров в одной команде рекомендуется разделять их с помощью знака канала |.

Фильтры

Фильтры представляют собой стандартные команды Linux, которые могут быть использованы без каналов:

- `find` — возвращает файлы с именами, которые соответствуют передаваемому аргументу.
- `grep` — возвращает только строки, содержащие (или не содержащие) заданное регулярное выражение.
- `tee` — перенаправляет стандартный ввод как стандартный вывод и один или несколько файлов.
- `tr` — находит и заменяет одну строку другой.
- `wc` — подсчитывает символы, линии и слова.

Как правило, все нижеприведенные команды работают как фильтры, если у них нет аргументов (опции могут быть):

- `cat` — считывает данные со стандартного потока ввода и передает их на стандартный поток вывода. Без опций работает как простой повторитель. С опциями может фильтровать пустые строки, нумеровать строки и делать другую подобную работу.
- `head` — показывает первые 10 строк (или другое заданное количество), считанных со стандартного потока ввода.
- `tail` — показывает последние 10 строк (или другое заданное количество), считанные со стандартного потока ввода. Важный частный случай tail -f, который в режиме слежения показывает концовку файла. Это используется, в частности, для просмотра файлов журнальных сообщений.
- `cut` — вырезает столбец (по символам или полям) из потока ввода и передает на поток вывода. В качестве разделителей полей могут использоваться любые символы.
- sort — сортирует данные в соответствии с какими-либо критериями, например, арифметически по второму столбцу.
- `uniq` — удаляет повторяющиеся строки. Или (с ключом -с) не просто удалить, а написать сколько таких строк было. Учитываются только подряд идущие одинаковые строки, поэтому часто данные сортируются перед тем как отправить их на вход программе.
- `bc` — вычисляет каждую отдельную строку потока и записывает вместо нее результат вычисления.
- `hexdump` — показывает шестнадцатеричное представление данных, поступающих на стандартный поток ввода.
- `strings` — выделяет и показывает в стандартном потоке (или файле) то, что напоминает строки. Всё что не похоже на строковые последовательности, игнорируется. Команда полезна в сочетании с grep для поиска интересующих строковых последовательностей в бинарных файлах.
- `sed` — обрабатывает текст в соответствии с заданным скриптом. Наиболее часто используется для замены текста в потоке: sed s/было/стало/g.
- `awk` — обрабатывает текст в соответствии с заданным скриптом. Как правило, используется для обработки текстовых таблиц, например, вывод ps aux и т.д.
- `sh -s` — текст, который передается на стандартный поток ввода sh -s. может интерпретироваться как последовательность команд shell. На выход передается результат их исполнения.
- `ssh` — средство удаленного доступа ssh, может работать как фильтр, который подхватывает данные, переданные ему на стандартный поток ввода, затем передает их на удаленный хост и подает на вход процессу программы, имя которой было передано ему в качестве аргумента. Результат выполнения программы (то есть то, что она выдала на стандартный поток вывода) передается со стандартного вывода ssh.

Если в качестве аргумента передается файл, команда-фильтр считывает данные из этого файла, а не со стандартного потока ввода (есть исключения, например, команда tr, обрабатывающая данные, поступающие исключительно через стандартный поток ввода).

Команда tee, как правило, используется для просмотра выводимого содержимого при одновременном сохранении его в файл.

    wc ~/stream | tee file2

Допускается перенаправление нескольких потоков в один файл:

    ls -z >> file3 2>&1

В результате сообщение о неверной опции «z» в команде ls будет записано в файл t2, поскольку stderr перенаправлен в файл.

Для просмотра содержимого файла file3 введите команду cat:

    cat file3

В результате на дисплее терминала отобразиться следующее:

    ls: invalid option -- 'z'
    Try 'ls --help' for more information.

## Как запустить процесс в фоне Linux

Для выполнения команды в фоновом режиме достаточно добавить в конце символ амперсанда (&):

    command &

В фоновом режиме можно одновременно запускать сразу два, три, четыре процесса и даже больше.

Работая в фоновом режиме, команда все равно продолжает выводить сообщения в терминал, из которого была запущена. Для этого она использует потоки stdout и stderr,  которые можно закрыть при помощи следующего синтаксиса:

    command > /dev/null 2>&1 &

Здесь `>/dev/null 2>&1` обозначает, что stdout будет перенаправлен на `/dev/null`, а stderr — к stdout.

Узнать состояние всех остановленных и выполняемых в фоновом режиме задач в рамках текущей сессии терминала можно при помощи утилиты jobs c использованием опции -l:

    jobs -l

В любое время можно вернуть процесс из фонового режима на передний план. Для этого служит команда fg:

    fg

Если в фоновом режиме выполняется несколько программ, следует также указывать номер. Например:

    fg %1

Для завершения фонового процесса применяют команду kill с номером программы:

    kill %1

### Как перевести процесс в фоновый режим

Если изначально процесс был запущен обычным способом, его можно перевести в фоновый режим, выполнив следующие действия:

- Остановить выполнение команды, нажав комбинацию клавиш `Ctrl+Z`.
- Перевести процесс в фоновый режим при помощи команды `bg`.

    bg

### Работа процессов в фоне

Закрытие терминала путем нажатия на крестик в верхнем углу экрана влечет за собой завершение всех фоновых процессов. Впрочем, есть несколько способов сохранить их  после того как связь с интерактивной оболочкой прервется. Первый способ — это удаление задачи из очереди заданий при помощи команды disown:

    disown

Как и в предыдущих случаях, при наличии нескольких одновременно выполняемых процессов следует  указывать номер того, относительно которого будет выполнено действие:

    disown %1

Убедиться, что задачи больше нет в списке заданий, можно, использовав уже знакомую утилиту jobs -l. А чтобы просмотреть перечень всех запущенных процессов (в том числе и отключенных) применяется команда

    ps aux

Второй способ сохранить запущенные процессы после прекращения работы терминала — команда nohup. Она выполняет другую команду, которая была указана в качестве аргумента, при этом игнорирует все сигналы SIGHUP (те, которые получает процесс при закрытии терминала). Для запуска команды в фоновом режиме нужно написать команду в виде:

    nohup command &

### Как убить процесс Linux

Управление процессами в операционной системе Linux осуществляется с помощью сигналов. В том числе и завершение любого процесса. Сигналы передает система, но также их может передавать пользователь с помощью специальных команд или даже сочетаний клавиш в терминале. Когда процессу приходит сигнал о необходимости завершиться, он должен выполнить некоторые подготовительные действия.

Необходимо завершить дочерние процессы, удалить временные файлы, сокеты и так далее. Но в зависимости от сложности ситуации процесс может реагировать не на все сигналы. Рассмотрим основные сигналы, которые используются для завершения процесса:

**SIGINT** - самый безобидный сигнал завершения, означает Interrupt. Он отправляется процессу, запущенному из терминала с помощью сочетания клавиш `Ctrl+C`. Процесс правильно завершает все свои действия и возвращает управление;
**SIGQUIT** - это еще один сигнал, который отправляется с помощью сочетания клавиш, программе, запущенной в терминале. Он сообщает ей что нужно завершиться и программа может выполнить корректное завершение или проигнорировать сигнал. В отличие от предыдущего, она генерирует дамп памяти. Сочетание клавиш `Ctrl+/`;
**SIGHUP** - сообщает процессу, что соединение с управляющим терминалом разорвано, отправляется, в основном, системой при разрыве соединения с интернетом;
**SIGTERM** - немедленно завершает процесс, но обрабатывается программой, поэтому позволяет ей завершить дочерние процессы и освободить все ресурсы;
**SIGKILL** - тоже немедленно завершает процесс, но, в отличие от предыдущего варианта, он не передается самому процессу, а обрабатывается ядром. Поэтому ресурсы и дочерние процессы остаются запущенными.

Важно понимать, что нужно дать процессу возможность завершиться корректно. Желательно, чтобы порты и сокеты были освобождены, закрыты и удаленны временные файлы. Поэтому никогда не передавайте сразу SIGKILL. Передавайте сигналы завершения в последовательности, как они перечислены выше.

Сначала `Ctrl+C`, если это возможно, затем SIGTERM - он хоть и завершает процесс, но делает эту культурно, и только в крайнем случае SIGKILL. А теперь рассмотрим как убить процесс по pid Linux на практике.

    kill -сигнал pid_процесса

Сигнал представляет собой один из выше перечисленных сигналов для завершения процесса. По умолчанию, если этот параметр не указан, используется сигнал SIGTERM, что является очень правильно. Также нам нужно указать какой процесс нужно завершить. Для этого используется уникальный идентификатор процесса - PID.

Допустим, у нас выполняется утилита ping. Мы хотим ее завершить с помощью kill. Тогда, сначала мы узнаем ее идентификатор с помощью команды ps:

    ps aux | grep ping

В первой строчке отобразится сама утилита ping, а во второй сама программа ps. Берем нужный PID и завершаем процесс с помощью SIGTERM:

    kill 20446

Или:

    kill -TERM 20446

И только если после этой команды процесс продолжил висеть, а это вы можете проверить, выполнив ps. Только теперь можно выполнить SIGKILL:

    kill -KILL 20446

#### Как завершить процесс с помощью pkill

Утилита pkill - это оболочка для kill, она ведет себя точно так же, и имеет тот же синтаксис, только в качестве идентификатора процесса ей нужно передать его имя. Утилита сканирует директорию proc и находит PID первого процесса с таким именем, затем отправляет ему SIGTERM. Таким образом, вы можете убить процесс по имени Linux. Например, если мы хотим завершить тот же ping:

    pkill ping

Также можно вручную задать тип сигнала:

    pkill -TERM ping

Вместо ps, вы можете использовать утилиту pgrep для поиска pid процесса, убедимся что наша программа завершена:

    pgrep ping

## Запись man программы в txt файл

`man <programm_name> | col -b > man_<programm_name>.txt`

## Bash-скрипты

### Начало

Итак, если говорить о командной строке, она позволяет выполнить несколько команд за один раз, введя их через точку с запятой:

`pwd ; whoami`

Используя подобный подход, вы можете совмещать сколько угодно команд в одной строке, ограничение — лишь в максимальном количестве аргументов, которое можно передать программе. Определить это ограничение можно с помощью такой команды:

`getconf ARG_MAX`

#### Как устроены bash-скрипты

Создайте пустой файл с использованием команды touch. В его первой строке нужно указать, какую именно оболочку мы собираемся использовать. Нас интересует bash, поэтому первая строка файла будет такой:

`#!/bin/bash`

Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:

```bash
#!/bin/bash
# This is a comment
pwd
whoami
```

Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.

#### Установка разрешений для файла сценария

Сделаем файл исполняемым:

`chmod +x ./myscript`

Теперь попытаемся его выполнить:

`./myscript`

#### Вывод сообщений

Для вывода текста в консоль Linux применяется команда echo. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:

```bash
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

#### Использование переменных

Существуют два типа переменных, которые можно использовать в bash-скриптах:

- Переменные среды
- Пользовательские переменные

##### Переменные среды

Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:

```bash
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"

#  если не нужно ссылаться на переменную
echo "I have \$1 in my pocket"
```

##### Пользовательские переменные

Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:

```bash
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

#### Подстановка команд

Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.

Сделать это можно двумя способами.

- С помощью значка обратного апострофа `«`»`
- С помощью конструкции `$()`

Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:

```bash
mydir=`pwd`
```


При втором подходе то же самое записывают так:

```bash
mydir=$(pwd)
```

А скрипт, в итоге, может выглядеть так:

```bash
#!/bin/bash
mydir=$(pwd)
echo $mydir
```

#### Математические операции

```bash
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

#### Управляющая конструкция if-then

выглядит так:

if команда
then
команды
fi

А вот рабочий пример:

```bash
#!/bin/bash
if pwd
then
echo "It works"
fi
```

Скажем, надо найти некоего пользователя в /etc/passwd, и если найти его удалось, сообщить о том, что он существует.

```bash
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
```

#### Управляющая конструкция if-then-else

if команда
then
команды
else
команды
fi

Напишем такой скрипт:

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
  then
    echo "The user $user Exists"
else
  echo "The user $user doesn’t exist"
fi
```

вложенные условия. Выглядит это так:

if команда1
then
команды
elif команда2
then
команды
fi

если вторая команда вернёт ноль, выполнится второй блок кода.

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
  then
    echo "The user $user Exists"
elif ls /home
  then
      echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

#### Сравнение чисел

`n1 -eq n2` Возвращает истинное значение, если n1 равно n2.
`n1 -ge n2` Возвращает истинное значение, если n1больше или равно n2.
`n1 -gt n2` Возвращает истинное значение, если n1 больше n2.
`n1 -le n2` Возвращает истинное значение, если n1меньше или равно n2.
`n1 -lt n2` Возвращает истинное значение, если n1 меньше n2.
`n1 -ne n2` Возвращает истинное значение, если n1не равно n2.

```bash
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
  then
    echo "The test value $val1 is greater than 5"
else
  echo "The test value $val1 is not greater than 5"
fi
```

#### Сравнение строк

`str1 = str2` Проверяет строки на равенство, возвращает истину, если строки идентичны.
`str1 != str2` Возвращает истину, если строки не идентичны.
`str1 < str2` Возвращает истину, если `str1` меньше, чем str2.
`str1 > str2` Возвращает истину, если `str1` больше, чем str2.
`-n str1` Возвращает истину, если длина `str1` больше нуля.
`-z str1` Возвращает истину, если длина `str1` равна нулю.

```bash
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

Вот как работа с этими операторами выглядит в коде:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:

`./myscript: line 5: [: too many arguments`

Для того, чтобы избавиться от этого предупреждения, заключим $val2 в двойные кавычки:

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах.

```bash
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

строчная буква больше прописной.

#### Проверки файлов

`-d file` Проверяет, существует ли файл, и является ли он директорией.
`-e file` Проверяет, существует ли файл.
`-f file` Проверяет, существует ли файл, и является ли он файлом.
`-r file` Проверяет, существует ли файл, и доступен ли он для чтения.
`-s file` Проверяет, существует ли файл, и не является ли он пустым.
`-w file` Проверяет, существует ли файл, и доступен ли он для записи.
`-x file` Проверяет, существует ли файл, и является ли он исполняемым.
`file1 -nt file2` Проверяет, новее ли file1, чем file2.
`file1 -ot file2` Проверяет, старше ли file1, чем file2.
`-O file` Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
`-G file` Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

Опробуем одну из команд на практике:

```bash
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
  then
    echo "The $mydir directory exists"
    cd $ mydir
    ls
else
  echo "The $mydir directory does not exist"
fi
```

### часть 2: циклы

#### Циклы for

структура таких циклов:

for var in list
do
команды
done

##### Перебор простых значений

```bash
#!/bin/bash
for var in first second third fourth fifth
  do
    echo The  $var item
  done
```

##### Перебор сложных значений

```bash
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
  do
    echo "This is: $var"
  done
```

##### Инициализация цикла списком, полученным из результатов работы команды

```bash
#!/bin/bash
file="myfile"
for var in $(cat $file)
  do
    echo " $var"
  done
```

Тут надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.

##### Разделители полей

Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:

- Пробел
- Знак табуляции
- Знак перевода строки

Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.

Для того, чтобы решить проблему, можно временно изменить переменную среды IFS. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:

`IFS=$'\n'`

После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.

```bash
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
  do
    echo " $var"
  done
```
Разделителями могут быть и другие символы. Например, выше мы выводили на экран содержимое файла /etc/passwd. Данные о пользователях в строках разделены с помощью двоеточий. Если в цикле нужно обрабатывать подобные строки, IFS можно настроить так:

`IFS=:`

##### Обход файлов, содержащихся в директории

вывести список файлов и папок:

```bash
#!/bin/bash
for file in /home/likegeeks/*
do
  if [ -d "$file" ]
  then
    echo "$file is a directory"
  elif [ -f "$file" ]
  then
    echo "$file is a file"
fi
done
```

##### Циклы for в стиле C

Схема цикла при подобном подходе выглядит так:

for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))


На bash это можно написать так:

`for (( a = 1; a < 10; a++ ))`

А вот рабочий пример:

```bash
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
  echo "number is $i"
done
```

#### Цикл while

while команда проверки условия

do

другие команды

done

Взглянем на пример скрипта с таким циклом:

```bash
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
  echo $var1
  var1=$[ $var1 - 1 ]
done
```

#### Вложенные циклы

```bash
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
  echo "Start $a:"
  for (( b = 1; b <= 3; b++ ))
  do
    echo " Inner loop: $b"
  done
done
```

#### Обработка содержимого файла

Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла /etc/passwd:

```bash
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
  echo "Values in $entry –"
  IFS=:
  for value in $entry
  do
    echo " $value"
  done
done
```

#### Управление циклами

##### Команда break

```bash
#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
do
  if [ $var1 -eq 5 ]
  then
    break
  fi
  echo "Iteration: $var1"
  var1=$(( $var1 + 1 ))
done
```

##### Команда continue

```bash
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
  if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
    then
      continue
  fi
  echo "Iteration number: $var1"
done
```

#### Обработка вывода, выполняемого в цикле

Оболочка создаст файл `myfile.txt` и перенаправит в этот файл вывод конструкции `for`

```bash
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
  echo "Number is $a"
done > myfile.txt
echo "finished."
```

#### Пример: поиск исполняемых файлов

```bash
#!/bin/bash
IFS=:
for folder in $PATH
do
  echo "$folder:"
  for file in $folder/*
  do
    if [ -x $file ]
      then
        echo " $file"
    fi
  done
done
```

### часть 3: параметры и ключи командной строки

Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Вызвав сценарий с параметрами, мы передаём ему некую информацию, с которой он может работать. Выглядит это так:

```bash
$ ./myscript 10 20
```
#### Чтение параметров командной строки

Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:

- $0 — имя скрипта.
- $1 — первый параметр.
- $2 — второй параметр — и так далее, вплоть до переменной $9, в которую попадает девятый параметр.

```bash
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
```

Запустим сценарий с параметрами:

`./myscript 5 10 15`

```bash
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```

Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:

`${10}`

#### Проверка параметров

Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:

```bash
#!/bin/bash
if [ -n "$1" ]
  then
    echo Hello $1.
else
  echo "No parameters found. "
fi
```

#### Подсчёт параметров

В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная $# содержит количество параметров, переданных сценарию при вызове.

Опробуем её:

```bash
#!/bin/bash
echo There were $# parameters passed.
```

#### Получение последнего параметра

```bash
#!/bin/bash
echo The last parameter was ${!#}
```

#### Захват всех параметров командной строки

Переменная `$*` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной `$@` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

Рассмотрим разницу между этими переменными на примерах. Сначала взглянем на их содержимое:

```bash
#!/bin/bash
echo "Using the \$* method: $*"
echo "-----------"
echo "Using the \$@ method: $@"
```

Теперь попробуем пройтись по содержимому этих переменных в циклах для того, чтобы увидеть разницу между ними:

```bash
#!/bin/bash
count=1
for param in "$*"
do
  echo "\$* Parameter #$count = $param"
  count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
  echo "\$@ Parameter #$count = $param"
  count=$(( $count + 1 ))
done
```

Переменная $* содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной $@ они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.

#### Команда shift

Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1, а то, что было до этого в $1, теряется. Обратите внимание на то, что при этом значение переменной $0, содержащей имя скрипта, не меняется.

```bash
#!/bin/bash
count=1
while [ -n "$1" ]
do
  echo "Parameter #$count = $1"
  count=$(( $count + 1 ))
  shift
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 1 2 3 4 5 6
Parameter #1 = 1
Parameter #2 = 2
Parameter #3 = 3
Parameter #4 = 4
Parameter #5 = 5
Parameter #6 = 6
```

Используя команду shift, помните о том, что при каждом её вызове значение переменной $1 безвозвратно теряется.

#### Ключи командной строки

Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:

```bash
#!/bin/bash
echo
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option" ;;
    -c) echo "Found the -c option" ;;
    *) echo "$1 is not an option" ;;
  esac
  shift
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr –a –b –c –d
–a is not an option
–b is not an option
–c is not an option
–d is not an option
```

#### Как различать ключи и параметры

Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Эта последовательность — двойное тире (--). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:

```bash
#!/bin/bash
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Found the -a option" ;;
    -b) echo "Found the -b option";;
    -c) echo "Found the -c option" ;;
    --) shift
      break ;;
    *) echo "$1 is not an option";;
  esac
  shift
done
  count=1
for param in $@
do
  echo "Parameter #$count: $param"
  count=$(( $count + 1 ))
done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr -a -b -c -d -- 4 5 15
Found the -a option
Found the -b option
Found the -c option
-d is not an option
Parameter #1: 4
Parameter #2: 5
Parameter #3: 15
```

#### Обработка ключей со значениями

`./myscript -a test1 -b -c test2`

```bash
#!/bin/bash
while [ -n "$1" ]
  do
    case "$1" in
      -a) echo "Found the -a option";;
      -b) param="$2"
        echo "Found the -b option, with parameter value $param"
        shift ;;
      -c) echo "Found the -c option";;
      --) shift
        break ;;
      *) echo "$1 is not an option";;
    esac
    shift
  done
count=1
for param in "$@"
  do
    echo "Parameter #$count: $param"
    count=$(( $count + 1 ))
  done
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr -a -b test1 -d
Found the -a option
Found the -b option, with parameter value test1
-d is not an option
```

#### Использование стандартных ключей

в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:

`-a` Вывести все объекты.
`-c` Произвести подсчёт.
`-d` Указать директорию.
`-e` Развернуть объект.
`-f` Указать файл, из которого нужно прочитать данные.
`-h` Вывести справку по команде.
`-i` Игнорировать регистр символов.
`-l` Выполнить полноформатный вывод данных.
`-n` Использовать неинтерактивный (пакетный) режим.
`-o` Позволяет указать файл, в который нужно перенаправить вывод.
`-q` Выполнить скрипт в quiet-режиме.
`-r` Обрабатывать папки и файлы рекурсивно.
`-s` Выполнить скрипт в silent-режиме.
`-v` Выполнить многословный вывод.
`-x` Исключить объект.
`-y` Ответить «yes» на все вопросы.

#### Получение данных от пользователя

Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда `read`

После получения данных, эта команда помещает их в переменную:

```bash
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
```

echo, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки

При вызове read можно указывать и несколько переменных:

```bash
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
```

Если, вызвав read, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`

```bash
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
```

Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду read можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:

```bash
#!/bin/bash
if read -t 5 -p "Enter your name: " name
  then
    echo "Hello $name, welcome to my script"
else
  echo "Sorry, too slow! "
fi
```

#### Ввод паролей

Ключ -s команды read предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда read делает цвет текста таким же, как цвет фона.

```bash
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
```

#### Чтение данных из файла

```bash
#!/bin/bash
count=1
cat myfile | while read line
  do
    echo "Line $count: $line"
    count=$(( $count + 1 ))
  done
echo "Finished"
```

### часть 4: ввод и вывод

#### Стандартные дескрипторы файлов

Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают.

- 0, STDIN — стандартный поток ввода.
- 1, STDOUT — стандартный поток вывода.
- 2, STDERR — стандартный поток ошибок.

#### STDIN

`STDIN` — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура. Когда в сценариях используют символ перенаправления ввода — `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.

Многие команды bash принимают ввод из `STDIN`, если в командной строке не указан файл, из которого надо брать данные. Например, это справедливо для команды `cat`.

Когда вы вводите команду cat в командной строке, не задавая параметров, она принимает ввод из `STDIN`. После того, как вы вводите очередную строку, cat просто выводит её на экран.

#### STDOUT

`STDOUT` — стандартный поток вывода оболочки. По умолчанию это — экран. Большинство bash-команд выводят данные в `STDOUT`, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`.

Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:

`pwd >> myfile`

То, что выведет `pwd`, будет добавлено к файлу `myfile`, при этом уже имеющиеся в нём данные никуда не денутся.

Пока всё хорошо, но что если попытаться выполнить что-то вроде показанного ниже, обратившись к несуществующему файлу `xfile`, задумывая всё это для того, чтобы в файл `myfile` попало сообщение об ошибке.

`ls –l xfile > myfile`

После выполнения этой команды мы увидим сообщения об ошибках на экране.

При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но мы-то хотели, чтобы сообщения об ошибках попали в файл. Что делать? Ответ прост — воспользоваться третьим стандартным дескриптором.

#### STDERR

`STDERR` представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает `STDOUT`, именно поэтому при возникновении ошибки мы видим сообщение на экране.

▍Перенаправление потока ошибок

Итак, предположим, что надо перенаправить сообщения об ошибках, скажем, в лог-файл, или куда-нибудь ещё, вместо того, чтобы выводить их на экран.

Как вы уже знаете, дескриптор файла `STDERR` — 2. Мы можем перенаправить ошибки, разместив этот дескриптор перед командой перенаправления:

```bash
ls -l xfile 2>myfile
cat ./myfile
```

Сообщение об ошибке теперь попадёт в файл `myfile`

▍Перенаправление потоков ошибок и вывода

При написании сценариев командной строки может возникнуть ситуация, когда нужно организовать и перенаправление сообщений об ошибках, и перенаправление стандартного вывода. Для того, чтобы этого добиться, нужно использовать команды перенаправления для соответствующих дескрипторов с указанием файлов, куда должны попадать ошибки и стандартный вывод:

```bash
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
```

Оболочка перенаправит то, что команда `ls` обычно отправляет в `STDOUT`, в файл `correctcontent` благодаря конструкции `1>`. Сообщения об ошибках, которые попали бы в `STDERR`, оказываются в файле `errorcontent` из-за команды перенаправления `2>`.

Если надо, и `STDERR`, и `STDOUT` можно перенаправить в один и тот же файл, воспользовавшись командой `&>`

```bash
ls –l myfile xfile anotherfile &> correctcontent
```

#### Перенаправление вывода в скриптах

Существует два метода перенаправления вывода в сценариях командной строки:

- Временное перенаправление, или перенаправление вывода одной строки.
- Постоянное перенаправление, или перенаправление всего вывода в скрипте либо в какой-то его части.

▍Временное перенаправление вывода

В скрипте можно перенаправить вывод отдельной строки в STDERR. Для того, чтобы это сделать, достаточно использовать команду перенаправления, указав дескриптор STDERR, при этом перед номером дескриптора надо поставить символ амперсанда (&):

```bash
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
This is an error
This is normal output
```

Запустим скрипт так, чтобы вывод STDERR попадал в файл.

`./myscript 2> myfile`

Как видно, теперь обычный вывод делается в консоль, а сообщения об ошибках попадают в файл.

▍Постоянное перенаправление вывода

Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову echo неудобно. Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой `exec`:

```bash
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
```

всё, что выводилось командами echo, попало в файл.


Команду exec можно использовать не только в начале скрипта, но и в других местах:

```bash
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
```

#### Перенаправление ввода в скриптах

Для перенаправления ввода можно воспользоваться той же методикой, которую мы применяли для перенаправления вывода. Например, команда exec позволяет сделать источником данных для STDIN какой-нибудь файл:

`exec 0< myfile`

Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл myfile, а не обычный STDIN. Посмотрим на перенаправление ввода в действии:

```bash
#!/bin/bash
exec 0< testfile
count=1
while read line
  do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
  done
```

#### Создание собственного перенаправления вывода

Перенаправляя ввод и вывод в сценариях, вы не ограничены тремя стандартными дескрипторами файлов. Как уже говорилось, можно иметь до девяти открытых дескрипторов. Остальные шесть, с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

Назначить дескриптор для вывода данных можно, используя команду `exec`:

```bash
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
```

#### Создание дескрипторов файлов для ввода данных

После окончания чтения файла можно восстановить STDIN и пользоваться им как обычно:

```bash
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line
  do
    echo "Line #$count: $line"
    count=$(( $count + 1 ))
  done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
  y) echo "Goodbye";;
  n) echo "Sorry, this is the end.";;
esac
```

#### Закрытие дескрипторов файлов

Оболочка автоматически закрывает дескрипторы файлов после завершения работы скрипта. Однако, в некоторых случаях нужно закрывать дескрипторы вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть дескриптор, его нужно перенаправить в &-. Выглядит это так:

```bash
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
```

мы попытались обратиться к несуществующему дескриптору.

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
./linux/2bash_sckr: line 6: 3: Bad file descriptor
```

#### Получение сведений об открытых дескрипторах

Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой `lsof`. Во многих дистрибутивах, вроде Fedora, утилита `lsof` находится в /usr/sbin. Эта команда весьма полезна, так как она выводит сведения о каждом дескрипторе, открытом в системе. Сюда входит и то, что открыли процессы, выполняемые в фоне, и то, что открыто пользователями, вошедшими в систему.

У этой команды есть множество ключей, рассмотрим самые важные.

- `-p` Позволяет указать ID процесса.
- `-d` Позволяет указать номер дескриптора, о котором надо получить сведения.

Для того, чтобы узнать PID текущего процесса, можно использовать специальную переменную окружения $$, в которую оболочка записывает текущий PID.

Ключ -a используется для выполнения операции логического И над результатами, возвращёнными благодаря использованию двух других ключей:

`lsof -a -p $$ -d 0,1,2`

Тип файлов, связанных с STDIN, STDOUT и STDERR — CHR (character mode, символьный режим). Так как все они указывают на терминал, имя файла соответствует имени устройства, назначенного терминалу. Все три стандартных файла доступны и для чтения, и для записи.

Посмотрим на вызов команды lsof из скрипта, в котором открыты, в дополнение к стандартным, другие дескрипторы:

```bash
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/2bash_sckr 
./linux/2bash_sckr: line 5: myfile3: No such file or directory
COMMAND       PID USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
2bash_sck 1480471 dima    0u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    1u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    2u   CHR  136,4      0t0        7 /dev/pts/4
2bash_sck 1480471 dima    3w   REG   8,17        0 42751766 /home/dima/javascript/projects/1test/myfile1
2bash_sck 1480471 dima    6w   REG   8,17        0 42751767 /home/dima/javascript/projects/1test/myfile2
```

#### Подавление вывода

Иногда надо сделать так, чтобы команды в скрипте, который, например, может исполняться как фоновый процесс, ничего не выводили на экран. Для этого можно перенаправить вывод в /dev/null. Это — что-то вроде «чёрной дыры».

Вот, например, как подавить вывод сообщений об ошибках:

`ls -al badfile anotherfile 2> /dev/null`

Тот же подход используется, если, например, надо очистить файл, не удаляя его:

`cat /dev/null > myfile`

### часть 5: сигналы, фоновые задачи, управление сценариями

как скрипт может работать с сигналами Linux, о различных подходах к запуску скриптов и к управлению ими во время работы.


Код сигнала      Название    Описание
 1	              SIGHUP	Закрытие терминала
 2	              SIGINT	Сигнал остановки процесса пользователем с терминала (CTRL + C)
 3	              SIGQUIT	Сигнал остановки процесса пользователем с терминала (CTRL + \) с дампом памяти
 9	              SIGKILL	Безусловное завершение процесса
 15	              SIGTERM	Сигнал запроса завершения процесса
 17	              SIGSTOP	Принудительная приостановка выполнения процесса, но не завершение его работы
 18	              SIGTSTP	Приостановка процесса с терминала (CTRL + Z), но не завершение работы
 19	              SIGCONT	Продолжение выполнения ранее остановленного процесса

#### Завершение работы процесса

Комбинация клавиш `CTRL + C` генерирует сигнал `SIGINT` и отправляет его всем процессам, выполняющимся в оболочке, что приводит к завершению их работы.

#### Временная остановка процесса

Комбинация клавиш `CTRL + Z` позволяет сгенерировать сигнал `SIGTSTP`, который приостанавливает работу процесса, но не завершает его выполнение.

Просмотреть приостановленные задания можно такой командой:

`ps –l`

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ps -l
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 T  1000 1605252 2148419  0  80   0 -  2023 do_sig pts/4    00:00:00 sleep
4 R  1000 1607323 2148419  0  80   0 -  2856 -      pts/4    00:00:00 ps
0 S  1000 2148419 2147908  0  80   0 -  3049 do_wai pts/4    00:00:01 bash
```

В колонке S, выводящей состояние процесса, для приостановленных процессов выводится T. Это указывает на то, что команда либо приостановлена, либо находится в состоянии трассировки.

Если нужно завершить работу приостановленного процесса, можно воспользоваться командой `kill`. Подробности о ней можно почитать здесь.

`kill processID`

#### Перехват сигналов

Для того, чтобы включить в скрипте отслеживание сигналов Linux, используется команда `trap`. Если скрипт получает сигнал, указанный при вызове этой команды, он обрабатывает его самостоятельно, при этом оболочка такой сигнал обрабатывать не будет.

Команда `trap` позволяет скрипту реагировать на сигналы, в противном случае их обработка выполняется оболочкой без его участия.

Команда `trap`, использованная в этом примере, выводит текстовое сообщение всякий раз, когда она обнаруживает сигнал `SIGINT`, который можно сгенерировать, нажав `Ctrl + C` на клавиатуре.

```bash
#!/bin/bash
trap "echo ' Trapped Ctrl-C'" SIGINT
echo This is a test script
count=1
while [ $count -le 10 ]
  do
    echo "Loop #$count"
    sleep 1
    count=$(( $count + 1 ))
  done
```

#### Перехват сигнала выхода из скрипта

Перехватить сигнал выхода из скрипта можно, использовав при вызове команды `trap` имя сигнала `EXIT`
При выходе из скрипта, будь то нормальное завершение его работы или завершение, вызванное сигналом `SIGINT`, сработает перехват и оболочка исполнит команду echo

```bash
#!/bin/bash
trap "echo Goodbye..." EXIT
count=1
while [ $count -le 5 ]
  do
    echo "Loop #$count"
    sleep 2
    count=$(( $count + 1 ))
  done
```

#### Модификация перехваченных сигналов и отмена перехвата

Для модификации перехваченных скриптом сигналов можно выполнить команду `trap` с новыми параметрами:

```bash
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
  do
    echo "Loop #$count"
    sleep 1
    count=$(( $count + 1 ))
  done
trap "echo ' I modified the trap!'" SIGINT
count=1
while [ $count -le 5 ]
  do
    echo "Second Loop #$count"
    sleep 1
    count=$(( $count + 1 ))
  done
```

Перехват сигналов можно и отменить, для этого достаточно выполнить команду `trap`, передав ей двойное тире и имя сигнала:

```bash
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
  do
    echo "Loop #$count"
    sleep 1
    count=$(( $count + 1 ))
  done
trap -- SIGINT
echo "I just removed the trap"
count=1
while [ $count -le 5 ]
  do
    echo "Second Loop #$count"
    sleep 1
    count=$(( $count + 1 ))
  done
```

#### Выполнение сценариев командной строки в фоновом режиме

Запустим его, указав после имени символ амперсанда (&):

`$ ./myscipt &`

Это приведёт к тому, что он будет запущен как фоновый процесс.

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr &
[3] 1645733
Loop #1
```

При таком подходе, если выйти из терминала, скрипт, выполняющийся в фоне, так же завершит работу.

#### Выполнение скриптов, не завершающих работу при закрытии терминала

Для этого можно воспользоваться командой `nohup`. Эта команда позволяет запустить программу, блокируя сигналы `SIGHUP`, отправляемые процессу. В результате процесс будет исполняться даже при выходе из терминала, в котором он был запущен.

`nohup ./myscript &`

Команда `nohup` отвязывает процесс от терминала. Это означает, что процесс потеряет ссылки на `STDOUT` и `STDERR`. Для того, чтобы не потерять данные, выводимые скриптом, nohup автоматически перенаправляет сообщения, поступающие в `STDOUT` и в `STDERR`, в файл `nohup.out`

при запуске нескольких скриптов из одной и той же директории то, что они выводят, попадёт в один файл `nohup.out`

#### Просмотр заданий

Команда `jobs` позволяет просматривать текущие задания, которые выполняются в оболочке. Напишем такой скрипт

Ключ `-l` при вызове команды jobs указывает на то, что нам нужны сведения об ID процессов.

#### Перезапуск приостановленных заданий

Запустим скрипт:

`$ ./myscript`

Нажмём `CTRL + Z`, что временно остановит его выполнение. Выполним следующую команду:

`$ bg`

Если у вас имеется несколько приостановленных заданий, для перезапуска конкретного задания команде `bg` можно передать его номер.

Для перезапуска задания в обычном режиме воспользуйтесь командой `fg`:

`$ fg 1`

#### Планирование запуска скриптов

Linux предоставляет пару способов запуска bash-скриптов в заданное время. Это команда `at` и планировщик заданий `cron`

`at [-f filename] time`

Эта команда распознаёт множество форматов указания времени.

- Стандартный, с указанием часов и минут, например — `10:15`.
- С использованием индикаторов AM/PM, до или после полудня, например — `10:15PM`.
- С использованием специальных имён, таких, как `now`, `noon`, `midnight`.

В дополнение к возможности указания времени запуска задания, команде at можно передать и дату, используя один из поддерживаемых ей форматов

- Стандартный формат указания даты, при котором дата записывается по шаблонам MMDDYY, MM/DD/YY, или DD.MM.YY.
- Текстовое представление даты, например, Jul 4 или Dec 25, при этом год можно указать, а можно обойтись и без него.
- Запись вида now + 25 minutes.
- Запись вида 10:15PM tomorrow.
- Запись вида 10:15 + 7 days.

`$ at -f ./myscript now`

Ключ `-M` при вызове `at` используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.

Для того чтобы посмотреть список заданий, ожидающих выполнения, можно воспользоваться командой

`$ atq`

#### Удаление заданий, ожидающих выполнения

Удалить задание, ожидающее выполнения, позволяет команда `atrm`. При её вызове указывают номер задания:

`$ atrm 18`

#### Запуск скриптов по расписанию

В Linux имеется утилита crontab, позволяющая планировать запуск скриптов, которые нужно выполнять регулярно.

`Crontab` выполняется в фоне и, основываясь на данных в так называемых cron-таблицах, запускает задания по расписанию.

Для того, чтобы просмотреть существующую таблицу заданий `cron`, воспользуйтесь такой командой:

`$ crontab –l`

При планировании запуска скрипта по расписанию crontab принимает данные о том, когда нужно выполнить задание, в таком формате:

`минута, час, день месяца, месяц, день недели.`

Например, если надо, чтобы некий скрипт с именем command выполнялся ежедневно в 10:30, этому будет соответствовать такая запись в таблице заданий:

`30 10 * * * command`

Если, например, надо, чтобы скрипт запускался в 4:30PM каждый понедельник, понадобится создать в таблице заданий такую запись:

`30 16 * * 1 command`

Нумерация дней недели начинается с 0, 0 означает воскресенье, 6 — субботу. Вот ещё один пример. Здесь команда будет выполняться в 12 часов дня в первый день каждого месяца.

`00 12 1 * * command`

Для того чтобы добавить запись в таблицу, нужно вызвать `crontab` с ключом `-e`:

`crontab –e`

Затем можно вводить команды формирования расписания:

`30 10 * * * /home/likegeeks/Desktop/myscript`

Если вы столкнётесь с ошибкой «Resource temporarily unavailable», выполните нижеприведённую команду с правами root-пользователя:

`$ rm -f /var/run/crond.pid`

Организовать периодический запуск скриптов с использованием cron можно ещё проще, воспользовавшись несколькими специальными директориями:

```bash
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
```

Если поместить файл скрипта в одну из них, это приведёт, соответственно, к его ежечасному, ежедневному, еженедельному или ежемесячному запуску.

Запуск скриптов при входе в систему и при запуске оболочки

Автоматизировать запуск скриптов можно, опираясь на различные события, такие, как вход пользователя в систему или запуск оболочки. Тут можно почитать о файлах, которые обрабатываются в подобных ситуациях. Например, это следующие файлы:

```bash
$HOME/.bash_profile
$HOME/.bash_login
$HOME/.profile
```

Для того, чтобы запускать скрипт при входе в систему, поместите его вызов в файл `.bash_profile`.

А как насчёт запуска скриптов при открытии терминала? Организовать это поможет файл `.bashrc`

### часть 6: функции и разработка библиотек

#### Объявление функций

Функцию можно объявить так:

```bash
function functionName {
}
```

Или так:

```bash
function functionName() {
}
```

#### Использование функций

```bash
#!/bin/bash
function myfunc {
  echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
  do
    myfunc
    count=$(( $count + 1 ))
  done
echo "This is the end of the loop"
myfunc
echo "End of the script"
```

Здесь создана функция с именем myfunc. Для вызова функции достаточно указать её имя.

- Функцию можно вызывать столько раз, сколько нужно
- Придумывая имена для функций, учитывайте то, что они должны быть уникальными
- попытавшись использовать функцию до её объявления, вы столкнётесь с ошибкой
- Если вы переопределите ранее объявленную функцию, новая функция будет вызываться вместо старой без каких-либо уведомлений или сообщений об ошибках

#### Использование команды return

Команда return позволяет задавать возвращаемый функцией целочисленный код завершения. Есть два способа работы с тем, что является результатом вызова функции. Вот первый:

```bash
#!/bin/bash
function myfunc {
  read -p "Enter a value: " value
  echo "adding value"
  return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"
```

Команда echo вывела сумму введённого числа и числа 10.

Функция `myfunc` добавляет `10` к числу, которое содержится в переменной `$value`, значение которой задаёт пользователь во время работы сценария. Затем она возвращает результат, используя команду `return`. То, что возвратила функция, выводится командой `echo` с использованием переменной `$?`.
Если вы выполните любую другую команду до извлечения из переменной `$?` значения, возвращённого функцией, это значение будет утеряно. Дело в том, что данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда `return` — `255`. Если функция должна возвращать большее число или строку, понадобится другой подход.

#### Запись вывода функции в переменную

Ещё один способ возврата результатов работы функции заключается в записи данных, выводимых функцией, в переменную. Такой подход позволяет обойти ограничения команды return и возвращать из функции любые данные. Рассмотрим пример:

```bash
#!/bin/bash
function myfunc {
  read -p "Enter a value: " value
  echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
```

#### Аргументы функций

Функции могут использовать стандартные позиционные параметры, в которые записывается то, что передаётся им при вызове. Например, имя функции хранится в параметре `$0`, первый переданный ей аргумент — в `$1`, второй — в `$2`, и так далее. Количество переданных функции аргументов можно узнать, обратившись к переменной `$#`

Аргументы передают функции, записывая их после её имени:

`myfunc $val1 10 20`

Вот пример, в котором функция вызывается с аргументами и занимается их обработкой:

```bash
#!/bin/bash
function addnum {
  if [ $# -eq 0 ] || [ $# -gt 2 ]
    then
      echo -1
  elif [ $# -eq 1 ]
    then
      echo $(( $1 + $1 ))
  else
    echo $(( $1 + $2 ))
  fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr 
Adding 10 and 15: 25
Adding one number: 20
Adding no numbers: -1
Adding three numbers: -1
```

Обратите внимание на то, что функция не может напрямую работать с параметрами, которые переданы скрипту при его запуске из командной строки. Например, напишем такой сценарий:

```bash
#!/bin/bash
function myfunc {
  echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
  then
    value=$( myfunc)
  echo "The result is $value"
else
  echo "Usage: myfunc  a b"
fi
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr 3 4
./linux/bash_sckr: line 3: +  : syntax error: operand expected (error token is "+  ")
The result is 
```

Вместо этого, если в функции планируется использовать параметры, переданные скрипту при вызове из командной строки, надо передать их ей при вызове:

```bash
#!/bin/bash
function myfunc {
  echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
  then
    value=$(myfunc $1 $2)
    echo "The result is $value"
else
  echo "Usage: myfunc a b"
fi
```

#### Работа с переменными в функциях

Существуют два вида переменных:

- Глобальные переменные.
- Локальные переменные.

##### Глобальные переменные

Глобальные переменные — это переменные, которые видны из любого места bash-скрипта. 

По умолчанию все объявленные в скриптах переменные глобальны. Так, к переменным, объявленным за пределами функций, можно без проблем обращаться из функций:

```bash
#!/bin/bash
function myfunc {
  value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr 3 4
Enter a value: 5
The new value is: 15
```

##### Локальные переменные

Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово `local` перед именем переменной:

`local temp=$(( $value + 5 ))`

Если за пределами функции есть переменная с таким же именем, это на неё не повлияет. Ключевое слово `local` позволяет отделить переменные, используемые внутри функции, от остальных переменных

```bash
#!/bin/bash
function myfunc {
  local temp=$[ $value + 5 ]
  echo "The Temp from inside function is $temp"
}
temp=4
myfunc
echo "The temp from outside is $temp"
```

##### Передача функциям массивов в качестве аргументов

```bash
#!/bin/bash
function myfunc {
  echo "The parameters are: $@"
  arr=$1
  echo "The received array is ${arr[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
myfunc $myarray
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr
The original array is: 1 2 3 4 5
The parameters are: 1
The received array is 1
```

Если надо, внутри функции полученные ей аргументы можно снова собрать в массив:

```bash
#!/bin/bash
function myfunc {
  local newarray
  newarray=("$@")
  echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr
The original array is 1 2 3 4 5
The new array value is: 1 2 3 4 5
```

#### Рекурсивные функции

```bash
#!/bin/bash
function factorial {
  if [ $1 -eq 1 ]
    then
      echo 1
  else
    local temp=$(( $1 - 1 ))
    local result=$(factorial $temp)
    echo $(( $result * $1 ))
  fi
}
read -p "Enter value: " value
result=$(factorial $value)
echo "The factorial of $value is: $result"
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test$ ./linux/bash_sckr
Enter value: 5
The factorial of 5 is: 120
```

#### Создание и использование библиотек

Оболочка bash позволяет создавать так называемые библиотеки — файлы, содержащие функции, а затем использовать эти библиотеки в любых скриптах, где они нужны.

Ключ к использованию библиотек — в команде `source`. Эта команда используется для подключения библиотек к скриптам. В результате функции, объявленные в библиотеке, становятся доступными в скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других скриптов.

У команды `source` есть псевдоним — оператор «точка». Для того, чтобы подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:

`. ./myscript`

Предположим, что у нас имеется файл myfuncs, который содержит следующее:

```bash
# ./myfuncs
function addnum {
  echo $(( $1 + $2 ))
}
```

Это — библиотека. Воспользуемся ей в сценарии:

```bash
#!/bin/bash
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
```

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ ./bash_sckr
The result is: 30
```

#### Вызов bash-функций из командной строки

```sh
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ . /home/dima/javascript/projects/1test/linux/myfun1 
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ addnum 10 20
30
```

### часть 7: sed и обработка текстов

#### Основы работы с sed

Утилиту sed называют потоковым текстовым редактором

Вот как выглядит схема вызова этой команды:

`$ sed options file`

По умолчанию sed применяет указанные при вызове правила, выраженные в виде набора команд, к STDIN. Это позволяет передавать данные непосредственно sed.

Например, так:

`$ echo "This is a test" | sed 's/test/another test/'`

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ echo "This is a test" | sed 's/test/another test/'
This is a another test
```

В данном случае sed заменяет слово «test» в строке, переданной для обработки, словами «another test».

Для оформления правила обработки текста, заключённого в кавычки, используются прямые слэши. В нашем случае применена команда вида `s/pattern1/pattern2/`. Буква «s» — это сокращение слова «substitute», то есть — перед нами команда замены. Sed, выполняя эту команду, просмотрит переданный текст и заменит найденные в нём фрагменты (о том — какие именно, поговорим ниже), соответствующие `pattern1`, на `pattern2`.

Ниже показан файл, в котором содержится фрагмент текста, и результаты его обработки такой командой:

`$ sed 's/test/another test' ./myfile`

Sed не меняет данные в обрабатываемом файле. Редактор читает файл, обрабатывает прочитанное, и отправляет то, что получилось, в `STDOUT`

При необходимости вывод sed можно перенаправить в файл, возможно — перезаписать старый файл

#### Выполнение наборов команд при вызове sed

Для выполнения нескольких действий с данными, используйте ключ `-e` при вызове `sed`. Например, вот как организовать замену двух фрагментов текста:

`$ sed -e 's/This/That/; s/test/another test/' ./myfile`

ля ввода нескольких шаблонов обработки текста при вызове sed, можно, после ввода первой одиночной кавычки, нажать Enter, после чего вводить каждое правило с новой строки, не забыв о закрывающей кавычке:

```bash
$ sed -e '
> s/This/That/
> s/test/another test/' ./myfile
```

Чтение команд из файла

Если имеется множество команд `sed`, с помощью которых надо обработать текст, обычно удобнее всего предварительно записать их в файл. Для того, чтобы указать sed файл, содержащий команды, используют ключ `-f`:

Вот содержимое файла mycommands:

```
s/This/That/
s/test/another test/
```

Вызовем sed, передав редактору файл с командами и файл для обработки:

`$ sed -f mycommands myfile`

Команда замены нормально обрабатывает файл, состоящий из нескольких строк, но заменяются только первые вхождения искомого фрагмента текста в каждой строке. Для того, чтобы заменить все вхождения шаблона, нужно использовать соответствующий флаг.

Схема записи команды замены при использовании флагов выглядит так:

`s/pattern/replacement/flags`

Выполнение этой команды можно модифицировать несколькими способами.

- При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.
- Флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.
- Флаг `p` указывает на то, что нужно вывести содержимое исходной строки.
- Флаг вида `w file` указывает команде на то, что нужно записать результаты обработки текста в файл.

Рассмотрим использование первого варианта команды замены, с указанием позиции заменяемого вхождения искомого фрагмента:

`$ sed 's/test/another test/2' myfile`

Тут мы указали, в качестве флага замены, число 2. Это привело к тому, что было заменено лишь второе вхождение искомого шаблона в каждой строке

Теперь опробуем флаг глобальной замены — `g`:

`$ sed 's/test/another test/g' myfile`

такая команда заменила все вхождения шаблона в тексте.

Флаг команды замены `p` позволяет выводить строки, в которых найдены совпадения, при этом ключ `-n`, указанный при вызове `sed`, подавляет обычный вывод:

`$ sed -n 's/test/another test/p' myfile`

Как результат, при запуске sed в такой конфигурации на экран выводятся лишь строки в которых найден заданный фрагмент текста.

Воспользуемся флагом `w`, который позволяет сохранить результаты обработки текста в файл:

`$ sed 's/test/another test/w output' myfile`

в ходе работы команды данные выводятся в `STDOUT`, при этом обработанные строки записываются в файл, имя которого указано после `w`.

Символы-разделители

Представьте, что нужно заменить `/bin/bash` на `/bin/csh` в файле `/etc/passwd`. Задача не такая уж и сложная:

`$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd`

`sed` позволяет нам самостоятельно задавать символы-разделители для использования их в команде замены. Разделителем считается первый символ, который будет встречен после `s`:

`$ sed 's!/bin/bash!/bin/csh!' /etc/passwd`

#### Выбор фрагментов текста для обработки

В некоторых случаях с помощью `sed` надо обработать лишь какую-то часть текста — некую конкретную строку или группу строк. Для достижения такой цели можно воспользоваться двумя подходами:

- Задать ограничение на номера обрабатываемых строк.
- Указать фильтр, соответствующие которому строки нужно обработать.

Рассмотрим первый подход. Тут допустимо два варианта. Первый, рассмотренный ниже, предусматривает указание номера одной строки, которую нужно обработать:

`$ sed '2s/test/another test/' myfile`

Второй вариант — диапазон строк:

`$ sed '2,3s/test/another test/' myfile`

Кроме того, можно вызвать команду замены так, чтобы файл был обработан начиная с некоей строки и до конца:

`$ sed '2,$s/test/another test/' myfile`

Для того, чтобы обрабатывать с помощью команды замены только строки, соответствующие заданному фильтру, команду надо вызвать так:

`$ sed '/likegeeks/s/bash/csh/' /etc/passwd`

По аналогии с тем, что было рассмотрено выше, шаблон передаётся перед именем команды `s`

#### Удаление строк

Утилита `sed` годится не только для замены одних последовательностей символов в строках на другие. С её помощью, а именно, используя команду `d`, можно удалять строки из текстового потока. из текста была удалена третья строка.

`$ sed '3d' myfile`

Если при вызове команды `d` не указать номер удаляемой строки, удалены будут все строки потока.

Вот как применить команду `d` к диапазону строк:

`$ sed '2,3d' myfile`

А вот как удалить строки, начиная с заданной — и до конца файла:

`$ sed '3,$d' myfile`

Строки можно удалять и по шаблону:

`$ sed '/test/d' myfile`

При вызове `d` можно указывать пару шаблонов — будут удалены строки, в которых встретится шаблон, и те строки, которые находятся между ними:

`$ sed '/second/,/fourth/d' myfile`

Вставка текста в поток

С помощью sed можно вставлять данные в текстовый поток, используя команды `i` и `a`:

- Команда `i` добавляет новую строку перед заданной.
- Команда `a` добавляет новую строку после заданной.

Рассмотрим пример использования команды `i`:

`$ echo "Another test" | sed 'i\First test '`

Теперь взглянем на команду `a`:

`$ echo "Another test" | sed 'a\First test '`

Как видно, эти команды добавляют текст до или после данных из потока. Что если надо добавить строку где-нибудь посередине?

Тут нам поможет указание номера опорной строки в потоке, или шаблона. Учтите, что адресация строк в виде диапазона тут не подойдёт. Вызовем команду `i`, указав номер строки, перед которой надо вставить новую строку:

`$ sed '2i\This is the inserted line.' myfile`

Проделаем то же самое с командой `a`:

`$ sed '2a\This is the appended line.' myfile`

Обратите внимание на разницу в работе команд `i` и `a`. Первая вставляет новую строку до указанной, вторая — после.

#### Замена строк

Команда `c` позволяет изменить содержимое целой строки текста в потоке данных. При её вызове нужно указать номер строки, вместо которой в поток надо добавить новые данные:

`$ sed '3c\This is a modified line.' myfile`

Если воспользоваться при вызове команды шаблоном в виде обычного текста или регулярного выражения, заменены будут все соответствующие шаблону строки:

`$ sed '/This is/c This is a changed line of text.' myfile`

#### Замена символов

Команда `y` работает с отдельными символами, заменяя их в соответствии с переданными ей при вызове данными:

`$ sed 'y/123/567/' myfile`

#### Вывод номеров строк

Если вызвать `sed`, использовав команду `=`, утилита выведет номера строк в потоке данных:

`$ sed '=' myfile`

<https://habr.com/ru/companies/ruvds/articles/327530/>

### часть 8: язык обработки данных awk

<https://habr.com/ru/companies/ruvds/articles/327754/>

### часть 9: регулярные выражения

#### Типы регулярных выражений

Реализации регулярных выражений в различных средах, например, в языках программирования вроде Java, Perl и Python, в инструментах Linux вроде sed, awk и grep, имеют определённые особенности. Эти особенности зависят от так называемых движков обработки регулярных выражений, которые занимаются интерпретацией шаблонов.
В Linux имеется два движка регулярных выражений:

- Движок, поддерживающий стандарт POSIX Basic Regular Expression (BRE).
- Движок, поддерживающий стандарт POSIX Extended Regular Expression (ERE).

##### Регулярные выражения POSIX BRE

регулярное выражение для поиска точного вхождения последовательности символов в тексте

```bash
$ echo "This is a test" | sed -n '/test/p'
$ echo "This is a test" | awk '/test/{print $0}'
```

поиск заданного шаблона выполняется без учёта точного места нахождения текста в строке. Кроме того, не имеет значение и количество вхождений. После того, как регулярное выражение найдёт заданный текст в любом месте строки, строка считается подходящей и передаётся для дальнейшей обработки

Работая с регулярными выражениями нужно учитывать то, что они чувствительны к регистру символов

В регулярных выражениях можно использовать не только буквы, но и пробелы, и цифры

##### Специальные символы

существуют некоторые специальные символы, или метасимволы, использование которых в шаблоне требует особого подхода. Вот они:

`.*[]^${}\+?|()`

Если один из них нужен в шаблоне, его нужно будет экранировать с помощью обратной косой черты (обратного слэша) — `\`

Знак доллара можно обнаружить с помощью такого шаблона:

`$ awk '/\$/{print $0}' myfile`

Кроме того, обратная косая черта — это тоже специальный символ, поэтому, если нужно использовать его в шаблоне, его тоже надо будет экранировать. Выглядит это как два слэша, идущих друг за другом:

`$ echo "\ is a special character" | awk '/\\/{print $0}'`

Хотя прямой слэш и не входит в приведённый выше список специальных символов. Если он нужен, его тоже надо экранировать:

`$ echo "3 / 2" | awk '/\//{print $0}'`

##### Якорные символы

Существуют два специальных символа для привязки шаблона к началу или к концу текстовой строки. Символ «крышка» — `^` позволяет описывать последовательности символов, которые находятся в начале текстовых строк

`$ echo "likegeeks website" | awk '/^likegeeks/{print $0}'`

При использовании `sed`, если поместить крышку где-нибудь внутри шаблона, она будет восприниматься как любой другой обычный символ:

`$ echo "This ^ is a test" | sed -n '/s ^/p'`

Что, если надо найти нечто, расположенное в конце строки?

В этом нам поможет знак доллара — `$`, являющийся якорным символом конца строки:

`$ echo "This is a test" | awk '/test$/{print $0}'`

В одном и том же шаблоне можно использовать оба якорных символа. Выполним обработку файла `myfile`, содержимое которого показано на рисунке ниже, с помощью такого регулярного выражения:

`$ awk '/^this is a test$/{print $0}' myfile`

шаблон среагировал лишь на строку, полностью соответствующую заданной последовательности символов и их расположению

Вот как, пользуясь якорными символами, отфильтровать пустые строки:

`$ awk '!/^$/{print $0}' myfile`

В данном шаблоне использовал символ отрицания, восклицательный знак — `!`. Благодаря использованию такого шаблона выполняется поиск строк, не содержащих ничего между началом и концом строки, а благодаря восклицательному знаку на печать выводятся лишь строки, которые не соответствуют этому шаблону.

##### Символ «точка»

Точка используется для поиска любого одиночного символа, за исключением символа перевода строки. Передадим такому регулярному выражению файл myfile, содержимое которого приведено ниже:

`$ awk '/.st/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
this is a test
This is another test
```

##### Классы символов

Точка соответствует любому одиночному символу, но что если нужно более гибко ограничить набор искомых символов? В подобной ситуации можно воспользоваться классами символов.

Благодаря такому подходу можно организовать поиск любого символа из заданного набора. Для описания класса символов используются квадратные скобки — `[]`:

`$ awk '/[oi]th/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
This is another test
start with this
```

Классы оказываются очень кстати, если выполняется поиск слов, которые могут начинаться как с прописной, так и со строчной буквы:

```bash
$ echo "this is a test" | awk '/[Tt]his is a test/{print $0}'
this is a test
```

```bash
$ echo "This is a test" | awk '/[Tt]his is a test/{print $0}'
This is a test
```

##### Отрицание классов символов

вместо поиска символов, входящих в класс, можно организовать поиск всего, что в класс не входит. Для того, чтобы добиться такого поведения регулярного выражения, перед списком символов класса нужно поместить знак `^`

`$ awk '/[^oi]th/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
And thes is one more
start with this
```

##### Диапазоны символов

В символьных классах можно описывать диапазоны символов, используя тире:

`$ awk '/[e-p]st/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
this is a test
This is another test
```

Диапазоны можно создавать и из чисел:

```bash
$ echo "123" | awk '/[0-9][0-9][0-9]/'
123
$ echo "12a" | awk '/[0-9][0-9][0-9]/'
```

В класс символов могут входить несколько диапазонов:

`$ awk '/[a-fm-z]st/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
this is a test
This is another test
```

Данное регулярное выражение найдёт все последовательности «st», перед которыми есть символы из диапазонов `a-f` и `m-z`

##### Специальные классы символов

В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:

- [[:alpha:]] — соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.
- [[:alnum:]] — соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах `0-9`, `A-Z`, `a-z`.
- [[:blank:]] — соответствует пробелу и знаку табуляции.
- [[:digit:]] — любой цифровой символ от `0` до `9`.
- [[:upper:]] — алфавитные символы в верхнем регистре — `A-Z`.
- [[:lower:]] — алфавитные символы в нижнем регистре — `a-z`.
- [[:print:]] — соответствует любому печатаемому символу.
- [[:punct:]] — соответствует знакам препинания.
- [[:space:]] — пробельные символы, в частности — пробел, знак табуляции, символы `NL`, `FF`, `VT`, `CR`.

```bash
$ echo "abc" | awk '/[[:alpha:]]/{print $0}'
abs
$ echo "abc" | awk '/[[:digit:]]/{print $0}'

$ echo "abc123" | awk '/[[:digit:]]/{print $0}'
abc123
```

##### Символ «звёздочка»

Если в шаблоне после символа поместить звёздочку, это будет означать, что регулярное выражение сработает, если символ появляется в строке любое количество раз — включая и ситуацию, когда символ в строке отсутствует.

```bash
$ echo "test" | awk '/tes*t/{print $0}'
test
$ echo "tessst" | awk '/tes*t/{print $0}'
tessst
```

Этот шаблонный символ обычно используют для работы со словами, в которых постоянно встречаются опечатки, или для слов, допускающих разные варианты корректного написания:

```bash
$ echo "I like green color" | awk '/colou*r/{print $0}'
I like green color
$ echo "I like green colour " | awk '/colou*r/{print $0}'
I like green colour
```

Ещё одна полезная возможность, вытекающая из особенностей символа звёздочки, заключается в комбинировании его с точкой. Такая комбинация позволяет регулярному выражению реагировать на любое количество любых символов:

`$ awk '/this.*test/{print $0}' myfile`

myfile
```
this is a test
This is another test
And thes is one more
start with this
```

rez
```
this is a test
```

Звёздочку можно использовать и с классами символов:

```bash
$ echo "st" | awk '/s[ae]*t/{print $0}'
st
$ echo "sat" | awk '/s[ae]*t/{print $0}'
sat
$ echo "set" | awk '/s[ae]*t/{print $0}'
set
```

#### Регулярные выражения POSIX ERE

##### Вопросительный знак

Вопросительный знак указывает на то, что предшествующий символ может встретиться в тексте один раз или не встретиться вовсе.

```bash
$ echo "tet" | awk '/tes?t/{print $0}'
tet
$ echo "test" | awk '/tes?t/{print $0}'
test
$ echo "tesst" | awk '/tes?t/{print $0}'
```

Вопросительный знак можно использовать и с классами символов:

```bash
$ echo "tst" | awk '/t[ae]?st/{print $0}'
tst
$ echo "test" | awk '/t[ae]?st/{print $0}'
test
$ echo "tast" | awk '/t[ae]?st/{print $0}'
tast
$ echo "taest" | awk '/t[ae]?st/{print $0}'
$ echo "teest" | awk '/t[ae]?st/{print $0
```

##### Символ «плюс»

Символ «плюс» в шаблоне указывает на то, что регулярное выражение обнаружит искомое в том случае, если предшествующий символ встретится в тексте один или более раз

```bash
$ echo "test" | awk '/te+st/{print $0}'
test
$ echo "teest" | awk '/te+st/{print $0}'
teest
$ echo "tst" | awk '/te+st/{print $0}'
```

Символ «плюс» работает и с классами символов — этим он похож на звёздочку и вопросительный знак:

```bash
$ echo "tst" | awk '/t[ae]+st/{print $0}'
$ echo "test" | awk '/t[ae]+st/{print $0}'
test
$ echo "teast" | awk '/t[ae]+st/{print $0}'
teast
$ echo "teeast" | awk '/t[ae]+st/{print $0}'
teeast
```

В данном случае если в строке имеется любой символ из класса, текст будет сочтён соответствующим шаблону.

##### Фигурные скобки

они позволяют точнее задавать необходимое число вхождений предшествующего им символа. Указывать ограничение можно в двух форматах:

- n — число, задающее точное число искомых вхождений
- n, m — два числа, которые трактуются так: «как минимум n раз, но не больше чем m».

```bash
$ echo "tst" | awk '/te{1}st/{print $0}'
$ echo "test" | awk '/te{1}st/{print $0}'
test
```

```bash
$ echo "tst" | awk '/te{1,2}st/{print $0}'
$ echo "test" | awk '/te{1,2}st/{print $0}'
test
$ echo "teest" | awk '/te{1,2}st/{print $0}'
teest
$ echo "teeest" | awk '/te{1,2}st/{print $0}'
```

```bash
$ echo "tst" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "test" | awk  '/t[ae]{1,2}st/{print $0}'
test
$ echo "teest" | awk  '/t[ae]{1,2}st/{print $0}'
teest
$ echo "teeast" | awk  '/t[ae]{1,2}st/{print $0}'
```

Шаблон отреагирует на текст в том случае, если в нём один или два раза встретится символ «a» или символ «e».

##### Символ логического «или»

Символ `|` — вертикальная черта, означает в регулярных выражениях логическое «или». Обрабатывая регулярное выражение, содержащее несколько фрагментов, разделённых таким знаком, движок сочтёт анализируемый текст подходящим в том случае, если он будет соответствовать любому из фрагментов.

```bash
$ echo "This is a test" | awk '/test|exam/{print $0}'
This is a test
$ echo "This is an exam" | awk '/test|exam/{print $0}'
This is an exam
$ echo "This is something else" | awk '/test|exam/{print $0}'
```

В данном примере регулярное выражение настроено на поиск в тексте слов «test» или «exam». Обратите внимание на то, что между фрагментами шаблона и разделяющим их символом `|` не должно быть пробелов

##### Группировка фрагментов регулярных выражений

Фрагменты регулярных выражений можно группировать, пользуясь круглыми скобками. Если сгруппировать некую последовательность символов, она будет восприниматься системой как обычный символ. То есть, например, к ней можно будет применить метасимволы повторений.

```bash
$ echo "Like" | awk '/Like(Geeks)?/{print $0}'
Like
$ echo "LikeGeeks" | awk '/Like(Geeks)?/{print $0}'
LikeGeeks
```

#### Практические примеры

##### Подсчёт количества файлов

```bash
#!/bin/bash
mypath=$(echo $PATH | sed 's/:/ /g')
count=0
for directory in $mypath
  do
    check=$(ls $directory)
    for item in $check
      do
        count=$[ $count + 1 ]
      done
    echo "$directory - $count"
    count=0
  done
```
```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ ./bash_sckr 
/home/dima/.local/bin/ - 39
/usr/local/lib/nodejs/node-v20.11.1-linux-x64/bin - 5
/home/dima/.local/bin - 39
/home/dima/.local/bin/ - 39
/usr/local/lib/nodejs/node-v20.11.1-linux-x64/bin - 5
/home/dima/.local/bin - 39
/usr/local/sbin - 0
/usr/local/bin - 7
/usr/sbin - 396
/usr/bin - 1689
/sbin - 396
/bin - 1689
/usr/games - 0
/usr/local/games - 0
/snap/bin - 43
```

##### Проверка адресов электронной почты

Подготовив шаблоны для отдельных частей регулярного выражения, соберём их вместе:

`^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$`

Теперь осталось лишь протестировать то, что получилось:

```bash
$ echo "name@host.com" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
name@host.com
$ echo "name@host.com.us" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
name@host.com.us
```

### часть 10: практические примеры

#### Отправка сообщений в терминал пользователя

<!-- ./senderscript -->
```bash
#!/bin/bash

logged_on=$(who | grep -i -m 1 $1 | awk '{print $1}')

if [ -z $logged_on ]
  then
    echo "$1 is not logged on."
    echo "Exit"
    exit
fi

allowed=$(who -T | grep -i -m 1 $1 | awk '{print $2}')

if [ $allowed != "+" ]
  then
    echo "$1 does not allowing messaging."
    echo "Exit"
    exit
fi

if [ -z $2 ]
  then
    echo "No message parameter included."
    echo "Exit"
    exit
fi

terminal=$(who | grep -i -m 1 $1 | awk '{print $2}')
shift

while [ -n "$1" ]
  do
    whole_message=$whole_message' '$1
    shift
  done

echo $whole_message | write $logged_on $terminal
```

`$ ./senderscript likegeeks welcome to shell scripting`

#### Скрипт для мониторинга дискового пространства










### expect

#### Основы expect

`$ apt-get install expect`

основные команды:

- `spawn` — запуск процесса или программы. Например, это может быть командная оболочка, FTP, Telnet, ssh, scp и так далее.

- `expect` — ожидание данных, выводимых программой. При написании скрипта можно указать, какого именно вывода он ждёт и как на него нужно реагировать.
- `send` — отправка ответа. Expect-скрипт с помощью этой команды может отправлять входные данные автоматизируемой программе. Она похожа на знакомую вам команду echo в обычных bash-скриптах.
- `interact` — позволяет переключиться на «ручной» режим управления программой.

#### Автоматизация bash-скрипта

скрипт, который взаимодействует с пользователем и автоматизируем его с помощью expect.

    ./qestions.sh
    #!/bin/bash
    echo "Hello, who are you?"
    read $REPLY
    echo "Can I ask you some questions?"
    read $REPLY
    echo "What is your favorite topic?"
    read $REPLY

expect-скрипт, который запустит скрипт questions и будет отвечать на его вопросы:

    ./answerbot.exp
    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Im Adam\r"
    expect "Can I ask you some questions?\r"
    send -- "Sure\r"
    expect "What is your favorite topic?\r"
    send -- "Technology\r"
    expect eof

В начале скрипта находится строка идентификации, которая, в данном случае, содержит путь к expect, так как интерпретировать скрипт будет именно expect.
Во второй строке мы отключаем тайм-аут, устанавливая переменную expect timeout в значение -1. Остальной код — это и есть автоматизация работы с bash-скриптом.

Сначала, с помощью команды spawn, мы запускаем bash-скрипт. Естественно, тут может быть вызвана любая другая утилита командной строки. Далее задана последовательность вопросов, поступающих от bash-скрипта, и ответов, которые даёт на них expect. Получив вопрос от подпроцесса, expect выдаёт ему заданный ответ и ожидает следующего вопроса.

В последней команде expect ожидает признака конца файла, скрипт, дойдя до этой команды, завершается.

`$ chmod +x ./answerbot.exp`
`$ chmod +x ./qestions.sh`

запускаем

`$./answerbot.exp`

узнать где expect

`$ which expect`

#### Autoexpect — автоматизированное создание expect-скриптов

Autoexpect позволяет запускать программы, которые надо автоматизировать, после чего записывает то, что они выводят, и то, что пользователь вводит, отвечая на их вопросы. Вызовем autoexpect, передав этой утилите имя нашего скрипта:

`$ autoexpect ./questions.sh`

отвечаем на вопросы questions.sh

После завершения работы с bash-скриптом, autoexpect сообщит о том, что собранные данные записаны в файл script.exp. Если запустить этот скрипт, результат будет тем же.

При записи сеансов взаимодействия с некоторыми программами, вроде FTP-клиентов, вы можете столкнуться с тем, что они используют в выводимых данных сведения о времени проведения операции, или выводят данные, отражающие процесс выполнения неких продолжительных действий. В целом, речь идёт о том, что вывод программы при каждом её запуске, правильно воспринимаемый человеком и вызывающий ввод одних и тех же ответов, будет, в тех же условиях, выглядеть по-новому для expect.

Если в expect-скрипте строки, ожидаемые от такой программы, будут жёстко зафиксированы, такой скрипт не сможет нормально работать. Справиться с этим можно, либо удалив из expect-скрипта данные, которые выглядят по-новому при каждом запуске программы, либо использовав шаблоны, пользуясь которыми, expect сможет правильно понять то, что хочет от него программа.

#### Работа с переменными и параметрами командной строки

Для объявления переменных в expect-скриптах используется команда set. Например, для того, чтобы присвоить значение 5 переменной VAR1, используется следующая конструкция:

`set VAR1 5`

Для доступа к значению переменной перед её именем надо добавить знак доллара — $. В нашем случае это будет выглядеть как $VAR1.

Для того, чтобы получить доступ к аргументам командной строки, с которыми вызван expect-скрипт, можно поступить так:

`set VAR [lindex $argv 0]`

Тут мы объявляем переменную `VAR` и записываем в неё указатель на первый аргумент командной строки, `$argv 0`.

Отредактируем скрипт answerbot, приведя его к такому виду:

    ./answerbot.exp
    #!/usr/bin/expect -f
    set my_name [lindex $argv 0]
    set my_favorite [lindex $argv 1]
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Im $my_name\r"
    expect "Can I ask you some questions?\r"
    send -- "Sure\r"
    expect "What is your favorite topic?\r"
    send -- "$my_favorite\r"
    expect eof

Запустим его, передав в качестве первого параметра SomeName, в качестве второго — Programming:

`$ ./answerbot SomeName Programming`

expect-скрипт отвечает на вопросы bash-скрипта, пользуясь переданными ему параметрами командной строки.

#### Ответы на разные вопросы, которые могут появиться в одном и том же месте

Если автоматизируемая программа может, в одной ситуации, выдать одну строку, а в другой, в том же самом месте — другую, в expect можно использовать блоки, заключённые в фигурные скобки и содержащие варианты реакции скрипта на разные данные, полученные от программы

Напишем новый скрипт, записав его в файл questions, случайным образом задающий в одном и том же месте разные вопросы:

    #!/bin/bash
    let number=$RANDOM
    if [ $number -gt 25000 ]
    then
    echo "What is your favorite topic?"
    else
    echo "What is your favorite movie?"
    fi
    read $REPLY

Тут мы генерируем случайное число при каждом запуске скрипта, и, проанализировав его, выводим один из двух вопросов.

Для автоматизации такого скрипта нам и пригодится вышеописанная конструкция:

    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect {
        "*topic?" { send -- "Programming\r" }
        "*movie?" { send -- "Star wars\r" }
    }

#### Условный оператор

использования условного оператора:

    #!/usr/bin/expect -f
    set TOTAL 1
    if { $TOTAL < 5 } {
    puts "\nTOTAL is less than 5\n"
    } elseif { $TOTAL > 5 } {
    puts "\nTOTAL greater than 5\n"
    } else {
    puts "\nTOTAL is equal to 5\n"
    }
    expect eof

`puts "text"` выводит text в консоль

Тут мы присваиваем переменной TOTAL некое число, после чего проверяем его и выводим текст, зависящий от результата проверки.

Обратите внимание на конфигурацию фигурных скобок. Очередная открывающая скобка должна быть расположена на той же строке, что и предыдущие конструкции.

#### Цикл while

Циклы while в expect очень похожи на те, что используются в обычных bash-скриптах, но, опять же, тут применяются фигурные скобки:

    #!/usr/bin/expect -f
    set COUNT 0
    while { $COUNT <= 5 } {
    puts "\nCOUNT is currently at $COUNT"
    set COUNT [ expr $COUNT + 1 ]
    }
    puts ""

Цикл for

Цикл for в expect устроен по-особому. В начале цикла, в самостоятельных парах фигурных скобок, надо указать переменную-счётчик, условие прекращения цикла и правило модификации счётчика. Затем, опять же в фигурных скобках, идёт тело цикла:

    #!/usr/bin/expect -f
    for {set COUNT 0} {$COUNT <= 5} {incr COUNT} {
    puts "\nCOUNT is at $COUNT"
    }
    puts ""

#### Объявление и использование функций

Expect позволяет программисту объявлять функции, используя ключевое слово proc:

    #!/usr/bin/expect -f

    proc myfunc { MY_COUNT } {
    set MY_COUNT [expr $MY_COUNT + 1]
    return "$MY_COUNT"
    }

    set COUNT 0
    while {$COUNT <= 5} {
    puts "\nCOUNT is currently at $COUNT"
    set COUNT [myfunc $COUNT]
    }
    puts ""

## Команда interact

Случается так, что автоматизируемые с помощью expect программы требуют ввода конфиденциальных данных, вроде паролей, которые вам не хотелось бы хранить в виде обычного текста в коде скрипта. В подобной ситуации можно воспользоваться командой interact, которая позволит вам, автоматизировав некую часть взаимодействия с программой, самостоятельно ввести, скажем, пароль, а потом опять передать управление expect.

Напишем expect-скрипт, который, когда ему предлагают предоставить пароль, передаёт управление нам:

    #!/usr/bin/expect -f
    set timeout -1
    spawn ./questions
    expect "Hello, who are you?\r"
    send -- "Hi Im Adam\r"
    expect "*password?\r"
    interact ++ return
    send "\r"
    expect "*topic?\r"
    send -- "Technology\r"
    expect eof

Встретив команду interact, expect-скрипт остановится, предоставив нам возможность ввести пароль. После ввода пароля надо ввести «++» и expect-скрипт продолжит работу, снова получив управление.

## tee

команда tee linux принимает данные из одного источника и может сохранять их на выходе в нескольких местах

### Синтаксис команды tee

```bash
tee опции файл
```

- `-a` или `-append` - Используется для записи вывода в конец существующего файла.
- `-i` или `-ignore-interrupts` - Используется, чтобы игнорировать прерывающие сигналы.
- `-help` - Используется для показа всех возможных операций.
- `-version` - Используется для показа текущей версии этой команды.

### 1. Простое использование команды tee

первая команда показала вывод списка файлов в текущем каталоге в терминал и записала полученные данные в файл вывод.txt, Вторая команда показала содержимое файла вывод.txt

```bash
ls -la | tee вывод.txt
cat вывод.txt
```

### 2. Добавление вывода в существующий файл

команда отображает вывод pwd в терминал и записывает вывод в конец файла вывод.txt

```bash
pwd | tee -a вывод.txt
```

### 3. Запись вывода в несколько файлов

```bash
date | tee вывод1.txt вывод2.txt
```

### 4. Игнорируем прерывание сигнала

ee linux с опцией -i используется в этом примере, чтобы игнорировать любые прерывания во время ее выполнения. Таким образом, команда будет выполнена правильно, даже если пользователь нажимает CTRL+C

первая команда считает количество строчек в файле вывод.txt и сохраняет полученный результат в файл вывод3.txt Вторая команда показывает содержимое файла вывод.txt, который содержит 37 строчек. Третья команда показывает содержимое файла вывод3.txt, в котором указано, что он действительно содержит 37 строчек

```bash
wc -l вывод.txt | tee -i вывод3.txt
cat вывод.txt
cat вывод3.txt
```

### 5. Перенос вывода команды tee в другую команду

Вывод команды tee может быть перенесен в другую команду. В этом примере вывод из первой команды переносится в tee, а ее вывод — в другую команду

```bash
ls | tee вывод4.txt | wc -lcw
```

Здесь первая команда используется для записи вывода ls в файл вывод4.txt и подсчета общего числа строк, слов и символов в файле вывод4.txt

### 6. Команда tee и скрипты

./add.sh
```bash
#!/bin/bash
a=$1
b=$2
((result=$a+$b))
echo "The addition of $a+$b=$result"
```

```bash
bash add.sh 40 80 | tee результат.txt
```

Здесь числа 40 и 80 переносятся в качестве аргументов командной строки в скрипт add.sh и вывод записывается в файл результат.txt 

### 7. Как скрыть вывод команды в терминале

команда используется для записи вывода команды df в файл вывод5.txt, при этом вывод не показывается в терминале

```bash
df | tee вывод5.txt > /dev/null
```

## ln

Команда ln в операционных системах, разработанных на основе ядра Linux, используется для создания символических и жестких ссылок на файлы.

### Ссылки на файл в Linux

#### Символические ссылки

Символическая ссылка — файл определенного типа, который выступает в роли линка на другой объект — файл любого формата или определенный каталог. Обычно такие объекты называют целевыми. Иногда вы можете заметить, что такой тип ссылок называют soft links или sym-link. Такой элемент не содержит в себе данных цели, а лишь выступает указателем, то есть является полной копией ярлыка из Виндовс. Внутри symbolic link находится только путь. Никто не запрещает вам создать множество подобных линков с разными именами, но одним и тем же целевым объектом. Связь между двумя составляющими называется мягкой, поскольку при удалении ссылки целевой файл никаким образом не страдает. Однако при удалении файла ссылка становится нерабочей. Она сохраняется на диске, но указанный в ней путь ведет уже к несуществующему объекту.

![soft links](images/links-1.drawio.svg)

эту ссылку можно перемещать в любое место на компьютере, от этого не зависит ее работоспособность, ведь она будет переходить по тому же пути, который был указан при создании.

#### Жесткие ссылки

Они, по сути, синонимы файла, но при этом не его копии. При создании жесткой ссылки будет сгенерирован еще один указатель на элемент. дела обстоят немного сложнее. Они, по сути, синонимы файла, но при этом не его копии. При создании жесткой ссылки будет сгенерирован еще один указатель на элемент. В файловой системе такие объекты определяются как еще один файл, поэтому при создании их в одной и той же директории с целью нельзя указывать одинаковое с ней имя. Все жесткие линки на файл должны находиться в одной ФС и не могут быть присвоены каталогу или несуществующему элементу.

![hard link](images/links-h.drawio.svg)

Важно отметить, что линк будет иметь точно такой же идентификатор (inode), как и целевой файл. Как известно, у всех объектов свои уникальные номера. Из-за этого между ними будет различие только в именах. Все права, владелец и даты изменений сохраняются. Можно сказать, что жесткая ссылка — еще одно название для объекта. При удалении целевого файла линк все равно будет хранить информацию, которая находилась в нем, поскольку на содержимое остается еще один указатель.

#### Создание ссылок

##### Символическая ссылка

```bash
ln -s file slink
```

 где file — имя или полный путь к файлу или директории, а slink — название ссылки. Она будет помещена в тот же каталог, где и находится целевой объект.

```bash
ls -li
```

 чтобы увидеть информацию по поводу находящихся в каталоге объектов.

#####  Жёстка ссылка

```bash
ln file hlink
```

## Что означает число в скобках, указанное после имен команд Unix в manpages?

Например: `man(1)`, `find(3)`, `updatedb(2)`?

Это раздел, которому назначена man-страница для команды.

Они разделены следующим образом

1. Общие команды
2. Системные вызовы
3. Функции библиотеки C
4. Специальные файлы (обычно устройства, которые находятся в /dev) и драйверы
5. Форматы файлов и соглашения
6. Игры и заставки
7. Сборник
8. Команды и демоны системного администрирования

Оригинальные описания каждого раздела можно увидеть в [Руководстве программиста Unix](https/web.archive.org/web/20170601064537/http://plan9.bell-labs.com/7thEdMan/v7vol1.pdf) (страница ii).

Чтобы получить доступ к справочной странице, заданной как "foo (5)", запустите:

`man 5 foo`

## Cron

### Как работает Cron?

сервис запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл `/etc/crontab`, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты run-parts, которая запускает нужные скрипты из следующих папок:

- `/etc/cron.minutely` - каждую минуту;
- `/etc/cron.hourly` - каждый час;
- `/etc/cron.daily` - каждый день;
- `/etc/cron.weekly` - каждую неделю;
- `/etc/cron.monthly` - каждый месяц.

В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле crontab прописан запуск команды anacron, которая работает так же как и cron, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.

Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл /var/spool/anacron, а затем, при следующем запуске anacron проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.

### Настройка Cron

Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла cron и специальная команда. Конечно, вы всегда можете отредактировать файл /etc/crontab, но этого делать не рекомендуется. Вместо этого, есть команда crontab:

```bash
crontab -e
```

Ее всегда желательно выполнять с опцией -e, тогда для редактирования правил будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл, в котором уже представлены все текущие правила cron и вы можете добавить новые. После завершения работы команды cron файл будет обработан и все правила будут добавлены в /var/spool/cron/crontabs/имя_пользователя причем добавленные процессы будут запускаться именно от того пользователя, от которого вы их добавляли.

Поэтому тут нужно быть аккуратным, и если вам нужно выполнять скрипты от рута, то и crontab нужно выполнить от рута, а не от пользователя. Это часто становится причиной проблем.

### Синтаксис crontab

```bash
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly>
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthl>
```

Нужно сказать, что обязательно нужно писать полный путь к команде, потому что для команд, запускаемых от имени cron переменная среды PATH будет отличаться, и сервис просто не сможет найти вашу команду. Это вторая самая распространенная причина проблем с Cron. Дата и время указываются с помощью цифр или символа '*'. Этот символ означает, что нужно выполнять каждый раз, если в первом поле - то каждую минуту и так далее. Ну а теперь перейдем к примерам.

### Примеры настройки cron

Сначала можно посмотреть задачи cron для суперпользователя, для этого можно воспользоваться опцией -l:

```bash
crontab -l
```

Вы можете удалить все существующие задачи командой -r:

```bahs
crontab -r
```

Давайте предположим, что нам нужно запускать от имени суперпользователя наш скрипт по адресу /usr/local/bin/serve. Какой-нибудь обслуживающий скрипт. Самый простой пример - запускать его каждую минуту:

`* * * * * /usr/local/bin/serve`

Далее, усложним, будем запускать каждый час, в нулевую минуту:

`0 * * * * /usr/local/bin/serve`

Запускаем в нулевую минуту нулевого часа, каждый день, это в 12 ночи:

`0 0 * * * /usr/local/bin/serve`

в первый день каждого месяца:

`0 0 1 * * /usr/local/bin/serve`

Можно в любой день, например, 15 числа:

`0 0 15 * * /usr/local/bin/serve`

В первый день недели первого месяца года, 0 часов 0 минут:

`0 0 * 1 0 /usr/local/bin/serve`

Или в нулевой день недели каждого месяца:

`0 0 * * 0 /usr/local/bin/serve`

Вы можете выбрать любую минуту, час и день недели, например, 15.30 во вторник:

`30 15 * * 2 /usr/local/bin/serve`

Понедельник считается первым днем, воскресенье - это седьмой или нулевой день. Еще можно писать сокращенное название дня недели, например sun - воскресенье:

`30 15 * * sun /usr/local/bin/serve`

Для того чтобы указать определенный интервал нужно использовать символ "-", например, каждый час, с семи утра до семи вечера:

`0 7-19  * * * /usr/local/bin/serve`

Если нужно запустить команду несколько раз, можно использовать разделитель ",". Например, запустим скрипт в 5 и 35 минут пятого (16:05 и 16:35), каждый день:

`5,35 16  * * * /usr/local/bin/serve`

Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, раз в 10 минут. Для этого используется разделитель косая черта - "/":

`*/10 * * * * /usr/local/bin/serve`

Кроме того, для некоторых часто используемых наборов были придуманы переменные, вот они:

`@reboot` - при загрузке, только один раз;
`@yearly`, @annually - раз год;
`@monthly` - раз в месяц;
`@weekly` - раз в неделю;
`@daily`, @midnight - каждый день;
`@hourly` - каждый час.

Например, вот так просто будет выглядеть команда запуска скрипта раз в час:

`@hourly /usr/local/bin/serve`

Если же вы собрались добавить скрипт в одну из папок, то, как я уже говорил, нужно чтобы его имя было без точек и у него были права на выполнение:

```bash
sudo vi /etc/cron.daily/backup

#!/bin/bash
......
```

### Отладка работы

После того как вы настроили правила, еще хотелось бы проверить работают ли они. Для этого ждем того времени, когда скрипт уже должен быть выполнен и смотрим лог cron. Иногда он находится в /var/log/cron, а иногда пишется в syslog. Например, у меня в crontab есть такая строка:

`40 19 * * * /usr/bin/ucaresystem-core`

Она должна выполняться в 19.40 каждый день, теперь смотрим лог:

`grep CRON /var/log/syslog`

```bash
Oct 14 00:17:01 dima-Nitro-AN515-52 CRON[601716]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 01:17:01 dima-Nitro-AN515-52 CRON[664626]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 08:17:01 dima-Nitro-AN515-52 CRON[696285]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 08:30:01 dima-Nitro-AN515-52 CRON[709713]: (root) CMD ([ -x /etc/init.d/anacron ] && if [ ! -d /run/systemd/system ]; then /usr/sbin/invoke-rc.d anacron start >/dev/null; fi)
Oct 14 19:07:01 dima-Nitro-AN515-52 CRON[713267]: (root) CMD (   test -x /etc/cron.daily/popularity-contest && /etc/cron.daily/popularity-contest --crond)
Oct 14 19:17:01 dima-Nitro-AN515-52 CRON[724460]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 19:30:02 dima-Nitro-AN515-52 CRON[738558]: (root) CMD ([ -x /etc/init.d/anacron ] && if [ ! -d /run/systemd/system ]; then /usr/sbin/invoke-rc.d anacron start >/dev/null; fi)
Oct 14 20:17:02 dima-Nitro-AN515-52 CRON[791555]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Oct 14 20:20:01 dima-Nitro-AN515-52 CRON[795003]: (dima) CMD (echo 'my coron command' >> /home/dima/test_cron.txt)
Oct 14 20:21:01 dima-Nitro-AN515-52 CRON[796158]: (dima) CMD (echo 'my coron command' >> /home/dima/test_cron.txt)
```

И видим что в нашем логе она действительно есть и выполняется целиком успешно. Если бы были какие-либо ошибки, то тут же было бы выведено сообщение.

Если нужно проверить скрипт, который находится в одной из специализированных папок, то тут еще проще, просто запустите run-paths, передав ей в параметр нужную папку или даже сам скрипт:

`sudo run-parts /etc/cron.daily/`

## Команда `useradd`. Создание пользователя в Linux

Вся информация о пользователях находится в файле `/etc/passwd`. Мы могли бы создать пользователя linux просто добавив его туда, но так делать не следует, поскольку для этой задачи существуют специальные утилиты. Одна из таких утилит, это useradd.

`$ useradd опции имя_пользователя`

опции команды:

- `-b` - базовый каталог для размещения домашнего каталога пользователя, по умолчанию `/home`;
- `-c` - комментарий к учетной записи;
- `-d` - домашний каталог, в котором будут размещаться файлы пользователя;
- `-e` - дата, когда учетная запись пользователя будет заблокирована, в формате ГГГГ-ММ-ДД;
- `-f` - заблокировать учетную запись сразу после создания;
- `-g` - основная группа пользователя;
- `-G` - список дополнительных групп;
- `-k` - каталог с шаблонами конфигурационных файлов;
- `-l` - не сохранять информацию о входах пользователя в lastlog и faillog;
- `-m` - создавать домашний каталог пользователя, если он не существует;
- `-M` - не создавать домашнюю папку;
- `-N` - не создавать группу с именем пользователя;
- `-o` - разрешить создание пользователя linux с неуникальным идентификатором UID;
- `-p` - задать пароль пользователя;
- `-r` - создать системного пользователя, не имеет оболочки входа, без домашней директории и с идентификатором до SYS_UID_MAX;
- `-s` - командная оболочка для пользователя;
- `-u` - идентификатор для пользователя;
- `-D` - отобразить параметры, которые используются по умолчанию для создания пользователя. Если вместе с этой опцией задать еще какой-либо параметр, то его значение по умолчанию будет переопределено.

какие параметры будут применены для пользователя по умолчанию:

`useradd -D`

создадим минимального пользователя с минимальными настройками

`sudo useradd test`

создадим пользователя с паролем и оболочкой `/bin/bash`

`sudo useradd -p password -s /bin/bash test1`

Для того чтобы получать доступ к системным ресурсам пользователю нужно быть участником групп, у которых есть доступ к этим ресурсам. Дополнительные группы пользователя задаются с помощью параметра -G. Например, разрешим пользователю читать логи, использовать cdrom и пользоваться sudo:

`sudo useradd -G adm,cdrom,wheel -p password -s /bin/bash test2`

установить дату, когда аккаунт пользователя будет отключен автоматически, это может быть полезно для пользователей, которые будут работать временно:

`sudo useradd -G adm,cdrom,wheel -p password -s /bin/bash -e 01:01:2018 test2`

Некоторых пользователей интересует создание пользователя с правами root linux, это очень просто делается с помощью useradd, если комбинировать правильные опции. Нам всего лишь нужно разрешить создавать пользователя с неуникальным uid, установить идентификатор в 0 и идентификатор основной группы тоже в 0. Команда будет выглядеть вот так:

`sudo useradd -o -u 0 -g 0 -s /bin/bash newroot`

## Команда `who`. Информация о пользователе

`who опции имя_файла аргументы`

### Опции who

- `-a` (--all) — включает в себя все основные опции.
- `-b` (--boot) — показывает время загрузки операционной системы.
- `-d` (--dead) — выводит перечень зомби-процессов.
- `-H` (--heading) — никак не влияет на получаемую информацию, зато добавляет колонкам заголовки и помогает понять что где находится.
- `-m` — показать пользователя, который сейчас работает в терминале.
- `-r` — вывести текущий уровень запуска (runinit);
- `-t` — показать последнее изменение системных часов;
- `-s` — вывести только имя, терминальную сессию и время.
- `-q` — вывести количество авторизованных пользователей.
- `-T` — данные о терминальной сессии.
- `-u` — показать активных пользователей.
- `--ips` — вместо названия хостов показывает ips.
- `--lookup` — используется в сочетании с --ips, выводит данные, которые основываются на сохраненном IP, если он доступен, а не на названии хоста.

### Примеры использования who

#### `who -a`

```bash
dima@dima-Nitro-AN515-52:~/javascript/projects/1test/linux$ who -a
           system boot  2024-09-29 11:32
dima     ? :0           2024-09-29 11:33   ?          2336 (:0)
           run-level 5  2024-09-29 11:33
```

В состав этой опции входят опции `-b`, `-d`, `--login`, `-p`, `-r`, `-t`, `-T`, `-u`

## Команда `su` Linux. Смена пользователя

`su [options] [-] [user]`

Если вызов команды происходит без аргументов, то происходит смена пользователя оболочки shell на суперпользователя root. Программа выдаст приглашение ввода пароля, если пароль будет верным, то текущим пользователем станет root.

- `options` — некоторые дополнительные возможности команды. Мы их рассмотрим ниже:
- `[-]` — смена контекста выполнения оболочки на контекст указанного пользователя. Переменные `$PATH`, `$HOME`, `$SHELL`, `$USER`, `$LOGNAME` содержат значения, характерные для указанного пользователя. Домашняя папка пользователя меняется на другую.
- `user` — имя пользователя, под которым продолжит работать командная оболочка.

Основные опции команды `su`:

- `-c`, `--command=command` — запускает приложение под указанным аккаунтом;
- `-s`, `--shell=shell` — происходит запуск для заданного пользователя указанной оболочки;
- `-`, `-l`, `--login` — смена контекста выполнения на контекст заданного пользователя, аналогична смене пользователя системы для shell;
- `-g`, `--group=group` — вызов пользователя, состоящего в заданной группе. Используется только для пользователя root;
- `-h`, `--help` — вызов справки для команды.

### Примеры использования su

Смена пользователя на суперпользователя root, без смены окружения оболочки:

`su`

Обратите внимание, что здесь вам нужно набрать пароль не своего пользователя, а именно того, от имени которого вы хотите авторизоваться. В данном случае, пользователя root. Если вы получаете ошибку сбой при проверке подлинности su linux, то это может означать, что либо вы ввели пароль неверно, либо пароль для этого пользователя не задан. Такое можно встретить у пользователя root в Ubuntu и Linux Mint. Информацию о том как установить пароль вы можете найти в этой (статье)[https://losst.pro/parol-root-v-ubuntu]

Смена пользователя на суперпользователя root со сменой параметров окружения оболочки:

`su -`

Смена пользователя на пользователя user01:

`su user01`

Смена пользователя на пользователя user01 со сменой окружения:

`su - user01`

Запуск оболочки zsh для пользователя user01:

`su -s /usr/bin/zsh user01`

Запуск оболочки bash из оболочки zsh для пользователя user01:

`su -s /usr/bin/bash user01`

Запуск файлового менеджера Midnight Commander для пользователя user01:

`su -c ‘mc’ user01`

## Как посмотреть список пользователей

В операционной системе Linux есть специальный файл в котором хранится информация обо всех пользователях. Это `/etc/passwd`. Записи в файле имеют следующий синтаксис:

`имя_пользователя пароль ид ид_группы группа домашний_каталог оболочка`

`cat /etc/passwd`

какие пользователи сейчас активны в системе, и какие команды они выполняют. Для этого есть утилита w:

`w`

Кроме того, вы можете посмотреть историю входов пользователей в систему. Для этого есть команда last, она выводит информацию на основе лога /var/wtmp:

`last -a`

Дату последнего входа для каждого пользователя вы можете посмотреть с помощью команды lastlog:

`lastlog`

## Суперпользователь в Ubuntu

суперпользователя в Ubuntu никто не отключал, пользователь root существует и от его имени работают процессы, как в других системах. Просто для этого пользователя не задан пароль. Поэтому вы и не можете войти. Но есть несколько способов авторизоваться от имени root без пароля. Во-первых, это sudo. Команда su запрашивает пароль только в том случае, если вы выполняете ее от имени обычного пользователя. Если команда будет запущена от имени суперпользователя, то пароль спрашиваться не будет, а вы сразу перейдете в терминал root. Первая комбинация, которая приходит на ум:

`sudo su`

Но есть и более простой и правильный вариант, вы можете использовать опцию -i утилиты sudo чтобы перейти в терминал суперпользователя:

`sudo -i`

установка пароля

Сначала смотрим /etc/shadow и убеждаемся, что пароля действительно нет:

`sudo cat /etc/shadow | grep root`

Для установки пароля для root наберите:

`sudo passwd root`

Теперь нужно ввести два раза пароль и готово. Проверяем снова:

`sudo cat /etc/shadow | grep root`

### Чтобы выйти из режима суперпользователя (root) в Linux

можно воспользоваться следующими способами:

- Использовать команду exit. Для этого нужно ввести её в терминале и нажать Enter. Команда завершит текущую сессию root и вернёт к предыдущему пользователю.
- Нажать комбинацию клавиш Ctrl+D. Она также завершит сессию и вернёт к обычному пользователю.
- Переключиться на другого пользователя с помощью команды su. Для этого нужно воспользоваться командой su с указанием имени пользователя: su имя_пользователя. После этого придётся ввести пароль для этого пользователя.
- Использовать команду logout. Если пользователь находится в интерактивной оболочке, то для выхода можно использовать команду logout.

При работе от имени root важно быть осторожным, так как можно случайно изменить или удалить важные системные файлы.

## Команда wait Bash

### Команда wait

Общий синтаксис wait имеет следующий вид:

`wait [options] ID`

`ID` — это идентификатор процесса или задания. Если ID не указан, команда ожидает завершения всех дочерних фоновых заданий.

Команда wait возвращает статус выхода последней ожидаемой команды.

Например, чтобы дождаться фонового процесса с PID 7654 , вы должны использовать:

`wait 7654`

Когда задано несколько процессов, команда ожидает завершения всех процессов.

Задания указываются с использованием спецификации задания («спецификация задания»), которая является способом ссылки на процессы, составляющие задание. Спецификация задания начинается с символа процента, за которым следует номер задания ( %n ). Вот пример:

Выполните команду в фоновом режиме :

`rsync -a /home /tmp/home &`

Идентификатор задания оболочки (в скобках) и идентификатор процесса будут отображаться на вашем терминале:

`[2] 54377`

Чтобы дождаться задания, запустите команду `wait` за которой следует спецификация задания:

`wait %2`

При вызове с параметром `-n` команда ожидает завершения только одного задания из заданных pid или заданий и возвращает статус завершения. Если аргументы не указаны, `wait -n` ожидает завершения любого фонового задания и возвращает статус завершения задания.

wait -n 45432 54346 76573

В приведенном выше примере `wait -n` выводит только статус возврата задания, которое завершается первым; он не показывает PID задания. Если вы хотите получить идентификатор задания или спецификацию задания, для которого возвращается статус выхода, используйте параметр `-p` чтобы присвоить его переменной:

`wait -p job_id -n 45432 54346 76573`

`-p` был представлен в Bash 5.1. Если вы используете старую версию Bash, вы получите ошибку «неверный вариант».

Параметр `-f` сообщает wait чтобы дождаться фактического завершения каждого pid или jobpec, прежде чем возвращать свой код выхода, вместо того, чтобы возвращаться при изменении статуса задания. Эта опция действительна, только если включено управление заданиями. По умолчанию управление заданиями включено только для интерактивных запросов.

### Примеры

wait обычно используется в сценариях оболочки, которые порождают дочерние процессы, выполняющиеся параллельно.

Чтобы проиллюстрировать, как работает команда, создайте следующий сценарий:

```bash
#!/bin/bash
sleep 30 &
process_id=$!
echo "PID: $process_id"
wait $process_id
echo "Exit status: $?"
```

Давайте объясним код построчно:

- Первая строка называется shebang и сообщает операционной системе, какой интерпретатор использовать для анализа остальной части файла.
- Мы используем команду `sleep` для имитации трудоемкого фонового процесса.
- `$!` — это внутренняя переменная Bash, в которой хранится PID последнего задания, запущенного в фоновом режиме. В этом примере это PID команды перехода в `sleep` . Мы сохраняем PID в переменной ( process_id ).
- Печатает номер PID.
- PID передается команде `wait` которая ожидает завершения команды sleep
- Печатает статус выхода команды `wait` . `$?` — это внутренняя переменная Bash, которая содержит статус выхода последней выполненной команды.

Если вы запустите сценарий, он напечатает что-то вроде этого:

```bash
PID: 36353
Exit status: 0
```

Вот пример использования опции `-n`

```bash
#!/bin/bash
sleep 3 &
sleep 30 &
sleep 5 &
wait -n
echo "First job completed."
wait
echo "All jobs completed."
```

Когда скрипт выполняется, он порождает 3 фоновых процесса. `wait -n` ожидает завершения первого задания и вывода оператора `echo`. `wait` ожидает завершения всех дочерних фоновых заданий.

```bash
first job completed
all jobs completed
```

Последний пример объясняет параметр `-f` . Откройте терминал и запустите:

```bash
sleep 3600 &

[1] 46671
```

Дождитесь процесса:

`wait 46671`

Откройте другой терминал и остановите процесс командой kill :

`kill -STOP 46671`

После изменения статуса процесса команда wait завершится и вернет код завершения процесса.

Теперь повторите те же шаги, но на этот раз используйте `wait -f $pid` :

```bash
sleep 3600 &
wait -f 46671
```

Остановите процесс с другого терминала:

`kill -STOP 46671`

На этот раз команда `wait` не завершится. Он будет работать до тех пор, пока не `sleep` процесс.

## Смена пользователя файла

`chown [новый пользователь]:[новая группа] [файл или папка]`

## tree

`$ tree опции`

### Опции которые отвечают за отображение дерева папок:

- `-a` — вывод всех без исключения файлов.
- `-d` — только список директорий.
- `-l` — переход по символическим ссылкам, которые ведут к папкам.
- `-f` — содержимое папок будет показано с префиксами пути.
- `-x` — учитывает только текущую файловую систему.
- `-L` — задает уровень вложенности для отображения в выводе.
- `-R` — рекурсивный переход по каталогам всех уровней.
- `-P` — отображение файлов, название которых соответствует шаблону.
- `-I` — исключение из вывода файлов, название которых соответствует шаблону.
- `-o` — печать вывода в файл с заданным именем.
- `--noreport` — запрещает команде выводить отчет по количеству папок и файлов в конце дерева.
- `--charset` — задает кодировки для отображения графических и html-файлов.
- `--filelimit` — папки, которые содержат больше файлов, чем указано, показаны не будут.

### опции используются для управления отображением названий документов:

- `-q` — заменяет непечатные символы в названиях файлов знаком ?.
- `-N` — выводит непечатные символы в названиях файлов как есть.
- `-Q` — заключает названия файлов в двойные кавычки.
- `-p` — для каждого из файлов указывает его название и список разрешенных действий.
- `-u` — печатает имя или идентификатор учетной записи, под которой был создан файл.
- `-g` — печатает имя или идентификатор группы пользователей, которая имеет права на доступ к файлу.
- `-s` — рядом с названием файла выводит его размер в байтах.
- `-h` — выводит размер файла в более простом для человеческого восприятия виде, добавляя к числу буквенное сокращение.
- `-D` — печатает дату последнего изменения файла (либо последнее изменение статуса в комбинации с опцией -c).
- `-F` — добавляет символ `/` для папок, `=` для файлов сокета, `*` для исполняемых файлов, `>` для door-файлов, `|` для специальных файлов FIFO.
- `--inodes` — выводит номера индексных дескрипторов для файлов и папок.
- `--device` — указывает номер устройства, к которому принадлежит файл или папка.

### Опции для сортировки результатов:

- `-v` — упорядочивает выдачу по уровням вложенности.
- `-t` — сортирует выдачу по дате последнего изменения файлов и папок.
- `-c` — сортирует выдачу по дате последнего изменения статуса.
- `-U` — результаты будут выведены в том порядке, в котором папки расположены на диске.
- `-r` — сортирует выдачу в обратном порядке.
- `--dirsfirst` — сначала будут показаны папки, потом — файлы.

### Опции отображения дерева:

- `-i` — убирает линии («ветки» дерева), файлы и папки отображаются в виде списка.
- `-n` — делает дерево одноцветным.
- `-C` — возвращает дереву разноцветное отображение после использования опции -n.

### Примеры использования tree

`tree`

`tree -d --filelimit 26` -  показывать только папки, установим ограничение на количество файлов, которые хранятся в папках (если файлов больше, папка не попадет в выдачу (нельзя устанавливать лимит меньше, чем 25 файлов)

`tree -avD` - показывает скрытые папки, упорядочить выдачу — например, по уровням вложенности (параметр -v), когда тот или иной файл был изменен последний раз — добавим к команде еще и -D

`tree -P '*.pdf' --prune` - отберем те, у которых формат pdf — сделать это позволяет опция -P. Она дает команде понять, что нужно выводить только документы, соответствующие маске. Чтобы задать маску для любого количества символов от 0 до бесконечности используется знак  *, а чтобы обозначить только 1 символ — знак ?.  Название файла или папки следует заключить в одинарные кавычки. Опция --prune нужна для того, чтобы исключить из выдачи папки, внутри которых нет  искомых документов (по умолчанию команда выводит даже те папки, которые не имеют отношения к поисковому запросу).

`tree -d -o tree_command_results.txt` - Опция -d использована для сокращения количества информации и ее присутствие здесь не обязательно. Опция -o  отвечает за перенаправление вывода в файл.

`tree -hupf` - Для получения дополнительной информации о файлах дополним команду tree опциями -h (показывает размер), -u (указывает на аккаунт, с которого файл был создан), -p (так мы узнаем, что можно делать с каждым конкретным файлом — только просматривать или также изменять его содержимое). Также используем параметр -f, чтобы видеть полный путь к каждому документу.

`tree -f -P '*studio*' --prune` - Полезный лайфхак — если объединить опции -P и -f, можно быстро находить файлы, затерявшиеся в памяти компьютера